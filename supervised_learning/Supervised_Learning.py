#!/usr/bin/env python
# coding: utf-8

# # Проект: Персонализация предложений постоянных клиентов интернет-магазина "В один клик"

# **Описание проекта:**
# 
# Интернет-магазин «В один клик» продаёт разные товары: для детей, для дома, мелкую бытовую технику, косметику и даже продукты. Отчёт магазина за прошлый период показал, что активность покупателей начала снижаться. Привлекать новых клиентов уже не так эффективно: о магазине и так знает большая часть целевой аудитории. Возможный выход — удерживать активность постоянных клиентов. Сделать это можно с помощью персонализированных предложений.
# 
# «В один клик» — современная компания, поэтому её руководство не хочет принимать решения просто так — только на основе анализа данных и бизнес-моделирования.

# **Цель проекта:** Разработать решение, которое позволит персонализировать предложения постоянным клиентам, чтобы увеличить их покупательскую активность.

# **Путь реализации проекта:**
# 
# Продумывать подход к решению этой задачи вам не придётся — руководитель отдела его уже **сформировал**:
# 
# 1. Нужно промаркировать уровень финансовой активности постоянных покупателей. В компании принято выделять два уровня активности: «снизилась», если клиент стал покупать меньше товаров, и «прежний уровень».
# 2. Нужно собрать данные по клиентам по следующим группам:
# - Признаки, которые описывают коммуникацию сотрудников компании с клиентом.
# - Признаки, которые описывают продуктовое поведение покупателя. Например, какие товары покупает и как часто.
# - Признаки, которые описывают покупательское поведение клиента. Например, сколько тратил в магазине.
# - Признаки, которые описывают поведение покупателя на сайте. Например, как много страниц просматривает и сколько времени проводит на сайте.
# 3. Нужно построить модель, которая предскажет вероятность снижения покупательской активности клиента в следующие три месяца.
# 4. В исследование нужно включить дополнительные данные финансового департамента о прибыльности клиента: какой доход каждый покупатель приносил компании за последние три месяца.
# 5. Используя данные модели и данные о прибыльности клиентов, нужно выделить сегменты покупателей и разработать для них персонализированные предложения.
# 
# Руководство **одобрило** описание решения, и вам нужно его реализовать.

# **Описание данных:**
# 
# **1.** Файл **market_file.csv** содержит данные о поведении покупателя на сайте, о коммуникациях с покупателем и его продуктовом поведении.
# - id — номер покупателя в корпоративной базе данных.
# - Покупательская активность — рассчитанный класс покупательской активности **(целевой признак)**: «снизилась» или «прежний уровень».
# - Тип сервиса — уровень сервиса, например «премиум» и «стандарт».
# - Разрешить сообщать — информация о том, можно ли присылать покупателю дополнительные предложения о товаре. Согласие на это даёт покупатель.
# - Маркет_актив_6_мес — среднемесячное значение маркетинговых коммуникаций компании, которое приходилось на покупателя за последние 6 месяцев. Это значение показывает, какое число рассылок, звонков, показов рекламы и прочего приходилось на клиента.
# - Маркет_актив_тек_мес — количество маркетинговых коммуникаций в текущем месяце.
# - Длительность — значение, которое показывает, сколько дней прошло с момента регистрации покупателя на сайте.
# - Акционные_покупки — среднемесячная доля покупок по акции от общего числа покупок за последние 6 месяцев.
# - Популярная_категория — самая популярная категория товаров у покупателя за последние 6 месяцев.
# - Средний_просмотр_категорий_за_визит — показывает, сколько в среднем категорий покупатель просмотрел за визит в течение последнего месяца.
# - Неоплаченные_продукты_штук_квартал — общее число неоплаченных товаров в корзине за последние 3 месяца.
# - Ошибка_сервиса — число сбоев, которые коснулись покупателя во время посещения сайта.
# - Страниц_за_визит — среднее количество страниц, которые просмотрел покупатель за один визит на сайт за последние 3 месяца.
# 
# **2.** Файл **market_money.csv** содержит информацию о выручке, которую получает магазин с покупателя, то есть сколько покупатель всего потратил за период взаимодействия с сайтом.
# - id — номер покупателя в корпоративной базе данных.
# - Период — название периода, во время которого зафиксирована выручка.
# - Выручка — сумма выручки за период.
# 
# **3.** Файл **market_time.csv** содержит информацию о времени (в минутах), которое покупатель провёл на сайте в течение периода.
# - id — номер покупателя в корпоративной базе данных.
# - Период — название периода, во время которого зафиксировано общее время.
# - минут — значение времени, проведённого на сайте, в минутах.
# 
# **4.** Файл **money.csv** содержит инфрмацию о среднемесячной прибыли продавца за последние 3 месяца: какую прибыль получает магазин от продаж каждому покупателю.
# - id — номер покупателя в корпоративной базе данных.
# - Прибыль — значение прибыли.

# **Инструкция по выполнению проекта:**
# 
# Решать задачу необходимо в два этапа:
# 1. Разработать модель, которая предскажет вероятность снижения покупательской активности.
# 2. Выделить сегмент покупателей, проанализировать его и предложить, как увеличить его покупательскую активность. Необходимо использовать данные моделирования, данные о прибыли покупателей и исходные данные (если понадобятся). По желанию можно проанализировать больше одного сегмента.

# **План работы с проектом:**
# 1. Загрузка и изучение данных;
# 2. Предобработка данных;
# 3. Исследовательский анализ данных;
# 4. Объединение таблиц;
# 5. Проведение корреляционного анализа;
# 6. Применение пайплайнов;
# 7. Анализ важности признаков;
# 8. Сегментация покупателей;
# 9. Формирование итоговых выводов.

# ## Загрузка и изучение данных

# In[1]:


# скачаем библиотеки, необходимые для работы
get_ipython().system('pip install shap -q')
get_ipython().system('pip -q install phik')


# In[2]:


# загрузим библиотеки, необходимые для работы
import pandas as pd
import math
import numpy as np

# загрузим библиотеки для визуализации данных
import matplotlib.pyplot as plt 
import seaborn as sns
import phik
import shap

# загрузим модули для работыы над конкретной задачей
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import StandardScaler, OneHotEncoder, OrdinalEncoder, MinMaxScaler
from sklearn.impute import SimpleImputer
from sklearn.model_selection import train_test_split, RandomizedSearchCV
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.svm import SVC
from sklearn.metrics import roc_auc_score, f1_score


# ### Загрузка и изучение данных датафрейма "market_file.csv "

# Файл **market_file.csv** содержит данные о поведении покупателя на сайте, о коммуникациях с покупателем и его продуктовом поведении.
# 
# **Описание данных:**
# 
# - id — номер покупателя в корпоративной базе данных.
# - Покупательская активность — рассчитанный класс покупательской активности (целевой признак): «снизилась» или «прежний уровень».
# - Тип сервиса — уровень сервиса, например «премиум» и «стандарт».
# - Разрешить сообщать — информация о том, можно ли присылать покупателю дополнительные предложения о товаре. Согласие на это даёт покупатель.
# - Маркет_актив_6_мес — среднемесячное значение маркетинговых коммуникаций компании, которое приходилось на покупателя за последние 6 месяцев. Это значение показывает, какое число рассылок, звонков, показов рекламы и прочего приходилось на клиента.
# - Маркет_актив_тек_мес — количество маркетинговых коммуникаций в текущем месяце.
# - Длительность — значение, которое показывает, сколько дней прошло с момента регистрации покупателя на сайте.
# - Акционные_покупки — среднемесячная доля покупок по акции от общего числа покупок за последние 6 месяцев.
# - Популярная_категория — самая популярная категория товаров у покупателя за последние 6 месяцев.
# - Средний_просмотр_категорий_за_визит — показывает, сколько в среднем категорий покупатель просмотрел за визит в течение последнего месяца.
# - Неоплаченные_продукты_штук_квартал — общее число неоплаченных товаров в корзине за последние 3 месяца.
# - Ошибка_сервиса — число сбоев, которые коснулись покупателя во время посещения сайта.
# - Страниц_за_визит — среднее количество страниц, которые просмотрел покупатель за один визит на сайт за последние 3 месяца.

# In[3]:


# загрузим данные из датафрейма "market_file.csv"
try:
    # локальный путь к файлу
    market_file = pd.read_csv('C:/Users/Admin/OneDrive/Рабочий стол/Проект/market_file.csv')
except:
    # путь к файлу в тренажере
    market_file = pd.read_csv('/datasets/market_file.csv')

# посмотрим первые 5 строк датафрема
market_file.head()


# In[4]:


# посмотрим общую информацию о датафрейме
market_file.info()


# **Примечание:** По полученным результатам видно, что данные соответствуют описанию задачи, также отсутствуют пропуски. Для корректной работы необходимо привести названия столбцов к общему стилю.

# ### Загрузка и изучение данных датафрейма "market_money.csv"

# Файл **market_money.csv** содержит информацию о выручке, которую получает магазин с покупателя, то есть сколько покупатель всего потратил за период взаимодействия с сайтом.
# 
# **Описание данных:**
# 
# - id — номер покупателя в корпоративной базе данных.
# - Период — название периода, во время которого зафиксирована выручка.
# - Выручка — сумма выручки за период.

# In[5]:


# загрузим данные из датафрейма "market_money.csv"
try:
    # локальный путь к файлу
    market_money = pd.read_csv('C:/Users/Admin/OneDrive/Рабочий стол/Проект/market_money.csv')
except:
    # путь к файлу в тренажёре
    market_money = pd.read_csv('/datasets/market_money.csv')

# посмотрим первые 5 строк датафрема
market_money.head()


# In[6]:


# посмотрим общую информацию о датафрейме
market_money.info()


# In[7]:


# посмотрим краткую сводку данных в датафреме
market_money.describe()


# **Примечание:** По полученным результатам видно, что данные в столбце "Выручка" не совсем соответствуют описанию задачи (присутствуют очень маленькие (0.00) и очень большие (106862.20) значения показателя). Пропуски отсутствуют. Для корректной работы необходимо привести названия столбцов к общему стилю.

# ### Загрузка и изучение данных датафрейма "market_time.csv"

# Файл **market_time.csv** содержит информацию о времени (в минутах), которое покупатель провёл на сайте в течение периода.
# 
# **Описание данных:**
# 
# - id — номер покупателя в корпоративной базе данных.
# - Период — название периода, во время которого зафиксировано общее время.
# - минут — значение времени, проведённого на сайте, в минутах.

# In[8]:


# загрузим данные из датафрейма "market_time.csv"
try:
    # локальный путь к файлу
    market_time = pd.read_csv('C:/Users/Admin/OneDrive/Рабочий стол/Проект/market_time.csv')
except:
    # путь к файлу в тренажёре
    market_time = pd.read_csv('/datasets/market_time.csv')
    
# посмотрим первые 5 строк датафрема
market_time.head()


# In[9]:


# посмотрим общую информацию о датафрейме
market_time.info()


# **Примечание:** По полученным результатам видно, что данные соответствуют описанию задачи, также отсутствуют пропуски.

# ### Загрузка и изучение данных датафрема "money.csv"

# Файл **money.csv** содержит инфрмацию о среднемесячной прибыли продавца за последние 3 месяца: какую прибыль получает магазин от продаж каждому покупателю.
# 
# **Описание данных:**
# 
# - id — номер покупателя в корпоративной базе данных.
# - Прибыль — значение прибыли.

# In[10]:


# загрузим данные из датафрейма "money.csv"
try:
    # локальный путь к файлу
    money = pd.read_csv('C:/Users/Admin/OneDrive/Рабочий стол/Проект/money.csv', sep=';', decimal=",")
except:
    # путь к файлу в тренажёре
    money = pd.read_csv('/datasets/money.csv', sep=';', decimal=",")
    
# посмотрим первые 5 строк датафрема
money.head()


# In[11]:


# посмотрим общую информацию о датафрейме
money.info()


# **Примечание:** По полученным результатам видно, что данные соответствуют описанию задачи, также отсутствуют пропуски.

# **Обобщающий вывод этапа "Загрузка и изучение данных":** 
# 1. Данные в трех из четырех таблиц соответсвуют описанию задачи.
# 2. В данных отсутствуют пропуски.
# 3. В каждой таблице необходимо привести названия столбцов к общему стилю.

# ## Предобработка данных

# ### Предобработка данных в таблице 'market_file'

# In[12]:


# по результатам загрузки данных стало видно, что в таблице 'market_file' названия столбцов необходимо привести к общему стилю
# выведем все названия столбцов
market_file.columns


# In[13]:


# переименуем столбцы к общепринятому стилю
market_file.columns = market_file.columns.str.lower().str.replace(' ', '_')

# выведем первые 5 строк таблицы с переименованными столбцами
market_file.head()


# In[14]:


# посмотрим количество пропусков в данных
market_file.isna().sum()


# **Примечание:** Пропуски в данных отсутствуют.

# In[15]:


# проверим датафрейм на наличие явных дубликатов
market_file.duplicated().sum()


# **Примечание:** Явные дубликаты в данных отсутствуют.

# In[16]:


# проверим наличие явных дубликатов по всем столбцам, кроме 'id', так как он всегду будет уникальным
market_file[market_file.duplicated(
    subset=['покупательская_активность', 'тип_сервиса', 'разрешить_сообщать',
           'маркет_актив_6_мес', 'маркет_актив_тек_мес', 'длительность',
           'акционные_покупки', 'популярная_категория',
           'средний_просмотр_категорий_за_визит',
           'неоплаченные_продукты_штук_квартал', 'ошибка_сервиса',
           'страниц_за_визит']
)] 


# **Примечание:** Если исключить из анализа на наличие явных дубликатов в таблице *'market_file'* столбец *'id'*, то можно обнаружить, что присутствует 11 явных дубликатов. В исходных данных всего 1300 строк, поэтому не будет пока удалять обнаруженные дубликаты.

# In[17]:


# проверим данные на наличие неявных дубликатов в столбцах с категориальными данными
# посмотрим значения в столбцах: 'покупательская_активность', 'тип_сервиса', 'разрешить_сообщать', 'популярная_категория'
print('Уникальные значения в столбце "покупательская_активность":', market_file['покупательская_активность'].unique())
print('Уникальные значения в столбце "тип_сервиса":', market_file['тип_сервиса'].unique())
print('Уникальные значения в столбце "разрешить_сообщать":', market_file['разрешить_сообщать'].unique())
print('Уникальные значения в столбце "популярная_категория":', market_file['популярная_категория'].unique())


# In[18]:


# заменим значения, которые могли привести к появлению неявных дубликатов
market_file['тип_сервиса'] = market_file['тип_сервиса'].replace('стандартт', 'стандарт')
market_file['популярная_категория'] = market_file['популярная_категория'].replace('Косметика и аксесуары', 'Косметика и аксессуары') 

# посмотрим уникальные значения в столбцах после замены
print('Уникальные значения в столбце "тип_сервиса":', market_file['тип_сервиса'].unique())
print('Уникальные значения в столбце "популярная_категория":', market_file['популярная_категория'].unique())


# **Примечание:** Замена проведена успешно.

# ### Предобработка данных в таблице 'market_money'

# In[19]:


# по результатам загрузки данных стало видно, что в таблице 'market_money' названия столбцов необходимо привести к общему стилю
# выведем все названия столбцов
market_money.columns


# In[20]:


# переименуем столбцы к общепринятому стилю
market_money.columns = market_money.columns.str.lower()

# выведем первые 5 строк таблицы с переименованными столбцами
market_money.head()


# In[21]:


# посмотрим количество пропусков в данных
market_money.isna().sum()


# **Примечание:** Пропуски в данных отсутствуют.

# In[22]:


# проверим датафрейм на наличие явных дубликатов
market_money.duplicated().sum()


# **Примечание:** Явные дубликаты в данных отсутствуют.

# In[23]:


# проверим данные на наличие неявных дубликатов в столбцах с категориальными данными
# посмотрим значения в столбце: 'период'
print('Уникальные значения в столбце "период":', market_money['период'].unique())


# **Примечание:** Неявные дубликаты в данных отсутствуют.

# ### Предобработка данных в таблице 'market_time'

# In[24]:


# по результатам загрузки данных стало видно, что в таблице 'market_time' названия столбцов необходимо привести к общему стилю
# выведем все названия столбцов
market_time.columns


# In[25]:


# переименуем столбцы к общепринятому стилю
market_time.columns = market_time.columns.str.lower()

# выведем первые 5 строк таблицы с переименованными столбцами
market_time.head()


# In[26]:


# посмотрим количество пропусков в данных
market_time.isna().sum()


# **Примечание:** Пропуски в данных отсутствуют.

# In[27]:


# проверим датафрейм на наличие явных дубликатов
market_time.duplicated().sum()


# **Примечание:** Явные дубликаты в данных отсутствуют.

# In[28]:


# проверим данные на наличие неявных дубликатов в столбцах с категориальными данными
# посмотрим значения в столбце: 'период'
print('Уникальные значения в столбце "период":', market_time['период'].unique())


# In[29]:


# заменим значения, которые могут привести к затруднению работы
market_time['период'] = market_time['период'].replace('предыдцщий_месяц', 'предыдущий_месяц')

# посмотрим уникальные значения в столбцах после замены
print('Уникальные значения в столбце "период":', market_time['период'].unique())


# **Примечание:** Замена проведена успешно.

# ### Предобработка данных в таблице 'money'

# In[30]:


# по результатам загрузки данных стало видно, что в таблице 'money' названия столбцов необходимо привести к общему стилю
# выведем все названия столбцов
money.columns


# In[31]:


# переименуем столбцы к общепринятому стилю
money.columns = money.columns.str.lower()

# выведем первые 5 строк таблицы с переименованными столбцами
money.head()


# In[32]:


# посмотрим количество пропусков в данных
money.isna().sum()


# **Примечание:** Пропуски в данных отсутствуют.

# In[33]:


# проверим датафрейм на наличие явных дубликатов
money.duplicated().sum()


# **Примечание:** Явные дубликаты в данных отсутствуют.

# **Обобщающий вывод этапа "Предобработка данных":**
# 1. В таблицах названия столбцов были приведены к общему стилю.
# 2. Пропуски в данных отсутствуют.
# 3. В таблице 'market_file' было найдено 11 явных дубликатов, но пока они удалены не были. В других трех таблицах явные дубликаты отсутствуют.
# 4. В таблицах 'market_file' и 'market_time' обработаны все неявные дубликаты.

# ## Исследовательский анализ данных

# ### Исследовательский анализ данных таблицы 'market_file'

# In[34]:


# проведем статистический анализ всех признаков в таблице 'market_file'
print('Описательная статистика для количественных признаков:')
market_file.describe(include=[np.number])


# In[35]:


print('Описательная статистика для категориальных признаков:')
market_file.describe(include=['object'])


# In[36]:


# построение графиков для разных типов признаков (количественных и категориальных)
# напишем собственную функцию для визулизации категориальных признаков
def categorical(data, column, title, figsize=(8, 5)):
    # устанавливаем параметры графика
    sns.set(style="whitegrid")
    plt.figure(figsize=figsize)
    
    # создаем график
    ax = sns.countplot(data = data, x=column, palette="viridis")
    
    # добавляем процентное соотношение по признакам
    total = len(data)
    for p in ax.patches:
        height = p.get_height()
        ax.text(p.get_x() + p.get_width()/2.,
                height + 0.01 * total,
                f'{height/total:.1%}',
                ha="center")

    # окончательная настройка графика
    plt.title(title)
    plt.xlabel(column)
    plt.ylabel('Количество')
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()


# In[37]:


# визуализация признака 'покупательская_активность'
categorical(market_file, 'покупательская_активность', 'Класс покупательской активности')


# In[38]:


# визуализация признака 'тип_сервиса'
categorical(market_file, 'тип_сервиса', 'Уровень сервиса')


# In[39]:


# визуализация признака 'разрешить_сообщать'
categorical(market_file, 'разрешить_сообщать', 'Согласие на рассылку дополнительных предложений о товаре')


# In[40]:


# визуализация признака 'популярная_категория'
categorical(market_file, 'популярная_категория', 'Самая популярная категория товаров у покупателя за последние 6 месяцев')


# In[41]:


# напишем собственную функцию для визуализации количественных признаков
def numeric(data, column, target, title):
    # устанавливаем параметры графика
    sns.set()
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 4))
    
    # построение гистограммы для количественных признаков
    sns.histplot(data, x=column, bins=20, kde=True, hue=target, ax=ax1)
    ax1.set_title(f'Гистограмма для {column}', fontsize=14)
    ax1.set_ylabel('Количество', fontsize=12)
    
    # построение графика "Ящик с усами"
    sns.boxplot(data=data, y=column, ax=ax2)
    ax2.set_title(f'Ящик с усами для {column}', fontsize=14)
    ax2.set_ylabel(column, fontsize=12)
    
    # окончательная настройка графика
    plt.suptitle(title)
    plt.tight_layout()
    plt.show()


# In[42]:


# визуализация признака 'маркет_актив_6_мес'
numeric(market_file, 'маркет_актив_6_мес', 'покупательская_активность', 'Число рассылок, звонков, показов рекламы на одного клиента за последние 6 мес.')


# **Примечание:** У данного признака на графике "Ящик с усами" прослеживаются некоторые небольшие выбросы ниже значения равного 2, они удалены не будут, так как не оказывают никакого значительного влияния на общую картину исследования.

# In[43]:


# визуализация признака 'маркет_актив_тек_мес'
numeric(market_file, 'маркет_актив_тек_мес', 'покупательская_активность', 'Количество маркетинговых коммуникаций в текущем мес.')


# **Примечание:** У данного признака получился довольно странный график "Ящик с усами". Признак отвечает за количество маркетинговых коммуникаций в текущем месяце, возможно, его можно отнести к группе категориальных признаков.

# In[44]:


# можно заметить, что значения в данном столбце носят дискретный характер
# поэтому для более полной визуализации построим график 'countplot', используя собственную функцию для категориальных признаков
categorical(market_file, 'маркет_актив_тек_мес', 'Количество маркетинговых коммуникаций в текущем мес.')


# In[45]:


# визуализация признака 'длительность'
numeric(market_file, 'длительность', 'покупательская_активность', 'Количество дней с момента регистрации покупателя на сайте')


# In[46]:


# визуализация признака 'акционные_покупки'
numeric(market_file, 'акционные_покупки', 'покупательская_активность', 'Среднемесячная доля покупок по акции от общего числа покупок за последние 6 мес.')


# **Примечание:** По графику можно заметить, что большинство покупателей не ориентируются на скидки, но тем не менее есть часть покупателей, которые все-таки ориентируются на скидки. В дальнейшем данный признак будет разумно идентифицировать, как категориальный признак, и рпзделить его на две категории: покупатели, которые отслеживают скидки и часто покупают товары по акции, и те покупатели, которые не занимаются этим.

# In[47]:


# визуализация признака 'средний_просмотр_категорий_за_визит'
numeric(market_file, 'средний_просмотр_категорий_за_визит', 'покупательская_активность', 'Количество категорий, просмотренных за визит в течение последнего мес.')


# In[48]:


# визуализация признака 'неоплаченные_продукты_штук_квартал'
numeric(market_file, 'неоплаченные_продукты_штук_квартал', 'покупательская_активность', 'Общее число неоплаченных товаров в корзине за последние 3 мес.')


# In[49]:


# визуализация признака 'ошибка_сервиса'
numeric(market_file, 'ошибка_сервиса', 'покупательская_активность', 'Число сбоев, которые произошли во время посещения сайта')


# In[50]:


# визуализация признака 'страниц_за_визит'
numeric(market_file, 'страниц_за_визит', 'покупательская_активность', 'Среднее количество страниц, которые просмотрел покупатель за один визит на сайт за последние 3 мес.')


# ### Исследовательский анализ данных таблицы 'market_money'

# In[51]:


# проведем статистический анализ всех признаков в таблице 'market_money'
print('Описательная статистика для количественных признаков:')
market_money.describe(include=[np.number])


# In[52]:


print('Описательная статистика для категориальных признаков:')
market_money.describe(include=['object'])


# In[53]:


# визуализация признака 'период'
categorical(market_money, 'период', 'Название периода, во время которого зафиксирована выручка')


# In[54]:


# создадим сводную таблицу, которая будет показывать сумму выручки за каждый период
market_money_period = market_money.pivot_table(index='период', values='выручка', aggfunc='sum')

# выведем полученную сводную таблицу
market_money_period


# In[55]:


# напишем собственную функцию для визуализации сводной таблицы
def pivot_plot(data, column):
    # создаем график
    sns.barplot(x=column, y=data.index, data=data).set(
        title=f'Распределение по {column}',
        xlabel='Количество'
    )
    
    # вывод графика
    plt.tight_layout()


# In[56]:


# визуализируем полученную сводную таблицу
pivot_plot(market_money_period, 'выручка')


# In[57]:


# визуализация признака 'выручка'
numeric(market_money, 'выручка', None, 'Сумма выручки за период')


# **Примечание:** На полученных графиках ярко прослеживается один выброс, его значение, которое можно получить из описательной статистики количественных признаков, равно 106 862.20. Причем по гистограмме можно сказать, что такой объем выручки принесла не группа покупателей, а всего лишь один покупатель. Такое значение можно отнести к аномалии, поэтому для качественной работы далее необходимо удалить строку с этими данными в таблице.

# In[58]:


# посмотрим аномально высокие значения
market_money.query('выручка > 100000')


# In[59]:


# подтвердилось, что такое большое значение выручки принес только один покупатель, поэтому это значение стоит удалить
# удалим аномальное значение
market_money = market_money[market_money['выручка'] < 100000]


# In[60]:


# снова построим визуализацию количественного признака 'выручка'
numeric(market_money, 'выручка', None, 'Сумма выручки за период')


# **Примечание:** На графике "Ящик с усами" снова видно выбросы, но только теперь это аномально маленькие значения, которые равны 0.00. Так как в дальнейшем целью исследования ставится задача работы с клиентами, чья покупательская активность не менее трех месяцев, то такие данные нам не подходят. Для качественной работы их стоит удалить.

# In[61]:


# посмотрим количество строк, чьи значения по столбцу 'выручка' равны 0.00
market_money.query('выручка < 1')


# In[62]:


# не подходящих нам значений всего 6, удалим их
market_money = market_money[market_money['выручка'] > 0]


# In[63]:


# снова построим визуализацию количественного признака 'выручка'
numeric(market_money, 'выручка', None, 'Сумма выручки за период')


# ### Исследовательский анализ данных таблицы 'market_time'

# In[64]:


# проведем статистический анализ всех признаков в таблице 'market_time'
print('Описательная статистика для количественных признаков:')
market_time.describe(include=[np.number])


# In[65]:


print('Описательная статистика для категориальных признаков:')
market_time.describe(include=['object'])


# In[66]:


# визуализация признака 'период'
categorical(market_time, 'период', 'Название периода, во время которого зафиксировано общее время')


# In[67]:


# создадим сводную таблицу, которая будет показывать сумму минут за конкретный период
market_time_period = market_time.pivot_table(index='период', values='минут', aggfunc='sum')

# выведем полученную сводную таблицу
market_time_period


# In[68]:


# визуализируем полученную сводную таблицу
pivot_plot(market_time_period, 'минут')


# In[69]:


# визуализация признака 'минут'
numeric(market_time, 'минут', None, 'Значение времени, проведённого на сайте, в минутах')


# ### Исследовательский анализ данных таблицы 'money'

# In[70]:


# проведем статистический анализ всех признаков в таблице 'money'
print('Описательная статистика для количественных признаков:')
money.describe(include=[np.number])


# In[71]:


# визуализация признака 'прибыль'
numeric(money, 'прибыль', None, 'Значение прибыли')


# ### Отбор активных пользователей

# Так как для исследования необходимо отобрать клиентов с покупательской активностью не менее трех месяцев, то будем рассматривать данные таблицы **'market_money'**, которые содержат значения выручки каждого клиента по периодам: "препредыдущий месяц", "предыдущий_месяц", "текущий_месяц".

# In[72]:


# проведем отбор пользователей с покупательской активностью за последние три месяца
market_file = market_file[market_file['id'].isin(
    market_money.groupby('id')['период'].count()
    .loc[lambda x: x == 3].index
)]

# выведем, сколько строк будет содержать исходная таблица после отбора
len(market_file)


# **Обобщающий вывод этапа "Исследовательский анализ данных":**
# 1. В таблице 'marlet_file' было выявлено небольшое количество выбросов у признака "маркет_актив_6_мес", но они не были удалены, так как в значительной мере не влияют на общий ход исследования. Также было выдвинуто предположение о том, что признаки "маркет_актив_тек_мес" и "акционные_покупки" можно отнести к ряду категориальных признаков.
# 2. В таблице 'market_money' для признака "выручка" были удалены аномально большие (больше 100 000) и аномально маленькие (равные 0.00) значения вырочки, которые могли бы негативно отразиться на исследовании.
# 3. В оставших двух таблицах все впорядке, аномалии обнаружены не были.
# 4. Был проведен отбор клиентов с покупательской активностью не менее трех месяцев, после отбора в исходном датафрейме осталось 1296 строк из исходных 1300 строк для анализа.

# ## Объединение таблиц

# In[73]:


# проведем объединение таблиц 'market_file', 'market_money' и 'market_time'
# 1. создадим отдельные столбцы со значением выручки для каждого периода
market_money_pivot = (
    market_money.pivot_table(index='id', columns='период')
    .set_axis(['выручка_предыдущий_месяц', 'выручка_препредыдущий_месяц', 'выручка_текущий_месяц'], axis=1)
    .reset_index()
)


# In[74]:


# 2. создадим отдельные столбцы со значениями минут (времени) для каждого периода
market_time_pivot = (
    market_time.pivot_table(index='id', columns='период')
    .set_axis(['минут_предыдущий_месяц', 'минут_текущий_месяц'], axis=1)
    .reset_index()
)


# In[75]:


# 3. проведем объединение всех таблиц (в том числе, полученных на 1-2 этапах) в одну
market = (
    market_file.join(market_money_pivot.set_index('id'), on='id', rsuffix="_выручка")
    .join(market_time_pivot.set_index('id'), on='id', rsuffix="_минут")
)


# In[76]:


# выведем первые 10 строк полученной объединенной таблицы
market.head(10)


# **Обобщающий вывод этапа "Объединение таблиц":** Все три таблицы были успешно объединены в одну.

# ## Корреляционный анализ

# 

# In[77]:


# создадим корреляционную матрицу
corr_matrix = market.phik_matrix()

# проведем визуализацию корреляционной матрицы
# построим тепловую карту
plt.figure(figsize=(12, 12))
sns.heatmap(
    corr_matrix,
    cmap='RdBu_r',
    annot=True,
    vmin=-1, vmax=1)

# окончательная настройка графика
plt.title('Матрица корреляции')
plt.show()


# **Обобщающий вывод этапа "Проведение корреляционного анализа":**
# 
# **Целевой признак:** "покупательская_активность"
# 1. Целовой признак имеет тесную корреляционную связь со следующими входными признаками:
# - "маркет_актив_6_мес";
# - "акционные_покупки";
# - "средний_просмотр_категорий_за_визит";
# - "неоплаченные_продукты_штук_квартал";
# - "страниц_за-визит";
# - "выручка_препредыдущий_месяц";
# - "минут_предыдущий_месяц";
# - "минут_текущий_месяц".
# 2. Между признаками "выручка_текущий_месяц" и "выручка_предыдущий_месяц" прослеживается высокий коэффициент корреляции, равный 0,84, данное явление похоже на мультиколинеарность, однако эти признаки пока что удалять не будем.
# 3. Между столбцом 'id' и целевым признаком "покупательская_активность" получился подозрительно очень высокий коэффициент корреляции. Такое явление является довольно странным, потому что столбец 'id' не оказывает никакого влияния на целевой признак. В дальнейше работе, чтобы устранить это явление, столбец 'id' стоит привести к столбцу с индексами.

# ## Использование пайплайнов

# ### Подготовка данных перед созданием пайплайна

# In[78]:


# переведем столбец 'id' в индексацию
market = market.set_index('id')

# посмотрим первые 5 строк новой таблицы
market.head()


# In[79]:


# переведем признак "акционные_покупки" в категориальный признак
market['акционные_покупки_скидки'] = market['акционные_покупки'].apply(lambda x: 'Покупает по акции' if x >= 0.5 else 'Не покупает по акции')

# удалим старый столбец "акционные_покупки" из таблицы
market = market.drop(['акционные_покупки'], axis=1)

# посмотрим первые 5 строк новой таблицы
market.head()


# In[80]:


# переведем целевой признак "покупательская_активность" в количественный признак
# где 1 = "Снизилась", а 0 = "Прежний уровень"
market['покупательская_активность'] = market['покупательская_активность'].apply(lambda x: 1 if x == 'Снизилась' else 0)

# посмотрим первые 5 строк новой таблицы
market.head()


# ### Создание пайплайна

# In[81]:


# введем константы
RANDOM_STATE = 42
TEST_SIZE = 0.25

X = market.drop('покупательская_активность', axis=1)
y = market['покупательская_активность']
    
# разбиваем данные на тренировочную и тестовую выборки
X_train, X_test, y_train, y_test = train_test_split(
    X, 
    y,
    test_size = TEST_SIZE,
    random_state=RANDOM_STATE,
    stratify = y)

# создаем списки с названиями признаков
ohe_columns = ['тип_сервиса', 'разрешить_сообщать', 'популярная_категория']

ord_columns = ['акционные_покупки_скидки']

num_columns = [
    'маркет_актив_6_мес', 'маркет_актив_тек_мес', 'длительность', 'средний_просмотр_категорий_за_визит',
    'неоплаченные_продукты_штук_квартал', 'ошибка_сервиса', 'страниц_за_визит', 'выручка_предыдущий_месяц',
    'выручка_препредыдущий_месяц', 'выручка_текущий_месяц', 'минут_предыдущий_месяц', 'минут_текущий_месяц'
]

# создаем пайплайн для подготовки признаков из списка ohe_columns
ohe_pipe = Pipeline(
    [
        (
            'simpleImputer_ohe', 
            SimpleImputer(missing_values=np.nan, strategy='most_frequent')
        ),
        (
            'ohe', 
            OneHotEncoder(drop='first', handle_unknown='error', sparse_output=False)
        )
    ]
) 

# создаем пайплайн для подготовки признаков из списка ord_columns
ord_pipe = Pipeline(
    [
        (
            'simpleImputer_before_ord', 
            SimpleImputer(missing_values=np.nan, strategy='most_frequent')
        ),
        (
            'ord',  
            OrdinalEncoder(
                categories=[
                    ['Покупает по акции', 'Не покупает по акции']
                ], 
                handle_unknown='use_encoded_value', unknown_value=np.nan
            )
        ),
        (
            'simpleImputer_after_ord', 
            SimpleImputer(missing_values=np.nan, strategy='most_frequent')
        )
    ]
)

# создаем общий пайплайн для подготовки данных
data_preprocessor = ColumnTransformer(
    [
        ('ohe', ohe_pipe, ohe_columns),
        ('ord', ord_pipe, ord_columns),
        ('num', MinMaxScaler(), num_columns)
    ], 
    remainder='passthrough'
)

# создаем итоговый пайплайн: подготовка данных и модель
pipe_final = Pipeline(
    [
        ('preprocessor', 
         data_preprocessor
        ),
        ('models', 
        DecisionTreeClassifier(random_state=RANDOM_STATE)
        )
    ]
)

param_grid = [
    # словарь для модели DecisionTreeClassifier()
    {
        'models': [DecisionTreeClassifier(random_state=RANDOM_STATE)],
        'models__max_depth': range(2, 5),
        'models__max_features': range(2, 5),
        'preprocessor__num': [StandardScaler(), MinMaxScaler(), 'passthrough']  
    },
    
    # словарь для модели KNeighborsClassifier() 
    {
        'models': [KNeighborsClassifier()],
        'models__n_neighbors': range(2, 5),
        'preprocessor__num': [StandardScaler(), MinMaxScaler(), 'passthrough']   
    },

    # словарь для модели LogisticRegression()
    {
        'models': [LogisticRegression(
            random_state=RANDOM_STATE, 
            solver='liblinear', 
            penalty='l1'
        )],
        'models__C': range(1, 5),
        'preprocessor__num': [StandardScaler(), MinMaxScaler(), 'passthrough']  
    },
    
    # словарь для модели SVC()
    {
        'models': [SVC(random_state=RANDOM_STATE, kernel='poly')],
        'models__degree': range(2, 3),
        'preprocessor__num': [StandardScaler(), MinMaxScaler(), 'passthrough']  

    }
]

randomized_search = RandomizedSearchCV(
    pipe_final, 
    param_grid, 
    cv=5,
    scoring='roc_auc',
    random_state=RANDOM_STATE,
    n_jobs=-1
)

randomized_search.fit(X_train, y_train)

print('Лучшая модель и её параметры:\n\n', randomized_search.best_estimator_)
print ('Метрика лучшей модели на тренировочной выборке:', randomized_search.best_score_)


# **Примечание:** Лучшая подель получилась LogisticRegression() с параметрами: (C=3, penalty='l1', random_state=42, solver='liblinear'). Метрика лучшей модели на тренировочной выборке: 0.89.

# In[82]:


# проверим работу модели на тестовой выборке
# рассчитаем прогноз на тестовых данных
y_test_pred = randomized_search.predict(X_test)
# выполним предсказание вероятностей
y_test_proba = randomized_search.predict_proba(X_test)

print(f'Метрика ROC-AUC на тестовой выборке: {roc_auc_score(y_test, y_test_proba[:,1])}')
print(f'Метрика F1-score на тестовой выборке: {f1_score(y_test, y_test_pred, average="macro")}')


# **Обобщающий вывод этапа "Применение пайплайнов":**
# 1. Наилучшей моделью оказалась **LogisticRegression()** с параметрами: (C=3, penalty='l1', random_state=42, solver='liblinear'). Метрика лучшей модели на тренировочной выборке: 0.89.
# 2. Для оценки качества модели LogisticRegression() лучше использовать метрики **ROC-AUC** и **F1-мера**, потому что они учитывают важные аспекты классификации, которые метрика *accuracy* может упустить. Также данные метрики учитывают дисбаланс классов.
# 3. На тестовой выборке значения метрик показали: ROC-AUC: 0.91 и F1-score: 0.89. Полученные значения являются достаточно высокими, а, значит, что модель хорошо справляется с предсказаниями.

# ## Анализ важности признаков

# Для оценки вклада признака в каждый прогноз будем использовать значения Шепли, их оценивают методом SHAP. Он вычисляет, как отдельный признак помог присвоить модели итоговое значение целевого.

# In[83]:


# получим предобработанные данные и имена признаков
preprocessor = pipe_final.named_steps['preprocessor']

# преобразуем тренировочные данные
X_train_SHAP = preprocessor.fit_transform(X_train)
# преобразуем тестовые данные
X_test_SHAP = pd.DataFrame(preprocessor.transform(X_test), columns=preprocessor.get_feature_names_out())

# создаем Explainer и вычисляем SHAP значения
explainer = shap.LinearExplainer(randomized_search.best_estimator_.named_steps['models'], X_train_SHAP)
shap_values = explainer(X_test_SHAP)

# проводим визуализацию результатов
# отобразим вклад признаков в каждое предсказание модели
shap.plots.beeswarm(shap_values, max_display=30)

# отобразим общий вклад признаков в прогнозы модели
shap.plots.bar(shap_values, max_display=30)


# **Обобщающий вывод этапа "Анализ важности признаков":**
# 
# По полученным методом SHAP графикам можно сказать, что:
# 1. **Мало значимые признаки для модели**: "выручка_предыдущий_месяц", "популярная_категория" (а именно: Техника для красоты и здоровья, Товары для детей, Кухонная посуда, Косметика и аксесуары), "выручка_текущий_месяц", "ошибка_сервиса", "длительность", "разрешить_сообщать" (оба ответа: да и нет), "тип_сервиса" (оба варианта" премиум и стандарт), "маркет_актив_тек_мес".
# 2. **Признаки, сильнее всего влияющие на целевой признак *("покупательская_активность")***: "страниц_за_визит", "средний_просмотр_категорий_за_визит", "минут_предыдущий_месяц", "минут_текущий_месяц", "неоплаченные_продукты_штук_квартал".
# 3. **Напишем выводы для сильно значимых признаков по графику beeswarm**:
# - Чем больше значения признаков "страниц_за_визит", "средний_просмотр_категорий_за-визит", "минут_предыдущий_месяц", "минут_текущий_месяц", тем меньше SHAP‑значения объектов. Если у наблюдения высокое значение этих признаков, то у него высокая вероятность принадлежности к классу 0.
# - Чем больше значения признака "неоплаченные_продукты_штук_квартал", тем выше SHAP-значения. Если у наблюдения высокое значение этого признака, то у него высокая вероятность принадлежности к классу 1.
# 5. **Как можно использовать эти наблюдения при моделировании и принятии бизнес-решений?** На мой взгляд, стоит делать упор на признаки, которые сильнее всего влияют на целевой признак *(перечислены в пункте №2)*. Для удержания постоянных клиентов и поддержания их покупательской активности необходимо, чтобы они проводили больше времени на сайте и просматривали как можно больше страниц за свое посещение. Это, в том числе, позволит увеличить среднее количество просмотренных категорий и количество добавленных в корзину товаров, даже если они пока что неоплаченные. С таким уровнем вовлеченности и большим выбором у клиента будет возможность обратиться к своей предварительно собранной корзине и выбрать оттуда товары, которые по душе среди различных альтернатив, чтобы совершить итоговую покупку, и принести прибыль интернет-магазину.

# ## Сегментация покупателей

# На данном этапе работы необходимо выделить сегмент покупателей, проанализировать его и предложить меры по увелечению его покупательской активности.
# 
# **Для сегментации будем использовать:** Группу клиентов с максимальной долей покупок по акции и высокой вероятностью снижения покупательской активности.

# ### Выполнение сегментации покупателей по результатам моделирования и данных о прибыльности покупателей

# In[84]:


# выберем данне о покупателях, вероятность принадлежности которых к классу 1 (т.е. "покупательска_активность = "Снизилась")
# возвращение вероятностей для тренировочных данных
y_train_proba = randomized_search.predict_proba(X_train)[:,1]

# возвращение вероятностей для тестовых данных
y_test_proba = randomized_search.predict_proba(X_test)[:,1]


# In[85]:


# посмотрим первые 5 строк таблицы с тестовыми данными
X_test.head()


# In[86]:


# выполним объединение данных в одну таблицу, добавив в нее: вероятности предсказаний модели и значения прибыли. 
sale = (
    pd.concat([
        X_train.assign(вероятность_снижения_активности=y_train_proba),
        X_test.assign(вероятность_снижения_активности=y_test_proba)
    ])
    .join(money.set_index('id'))
)


# In[87]:


sale.head()


# In[88]:


# визуализируем полученные результаты
# построим график "Зависимость прибыли от вероятности снижения активности"
sns.scatterplot(data=sale, x='вероятность_снижения_активности', y='прибыль')
plt.title('Зависимость прибыли от вероятности снижения активности')
plt.show()


# **Примечание:** Так как для сегментации заранее был выбран класс **"Группа клиентов с максимальной долей покупок по акции и высокой вероятностью снижения покупательской активности"**, посмотрим его.

# In[89]:


sns.scatterplot(data=sale, y='прибыль', x='вероятность_снижения_активности', hue='акционные_покупки_скидки')
plt.title('Зависимость вероятности снижения активности от выручки')
plt.show()


# **Примечание:** По полученному графику видно, что покупатели, которые покупают товары по акции, часто имеют вероятность к снижению их покупательской активности. Скорее всего, это может быть, связано с тем, что акции и скидки не длятся постоянно, поэтому покупки совершаются произвольно.

# ### Анализ выбранного сегмента покупателей

# In[90]:


# добавим новый столбец с разбивкой на покупателей, у которых высокая вероятность снижения покупательской активноти и которые часто покупают товары по скидкам
# 1. создадим новый столбец в таблице и для начала запишем в него всех пользователей
sale['сегментация_акции'] = 'Остальные пользователи'

# 2. с помощью фильтрации отберем нужные строки и просвоим им значение "Исследуемый сегмент"
sale.loc[(sale['вероятность_снижения_активности'] > 0.8) & (sale['акционные_покупки_скидки'] == 'Покупает по акции'), 'сегментация_акции'] = 'Исследуемый сегмент'

# 2. выведем первые 5 строк получившейся новой таблицы
sale.head()


# Проведем графическое и аналитическое исследование отобранной группы покупателей (по столбцу "сегментация_акции").

# In[91]:


# визуализация признака 'тип_сервиса'
categorical(sale, 'тип_сервиса', 'Уровень сервиса')


# **Примечание:** Покупатели, выбранные нами в "Исследуемый сегмент" стремятся покупать товары по акции и в основном на уровне сервиса "стандарт", но, как показывает график, товары уровня сервис "премиум" иногда тоже покупаются.

# In[92]:


# напишем собственную функцию для визуализации количественных признаков отобранного сегмента
def numeric_segment(data, column, target, title):
    # устанавливаем параметры графика
    sns.set()
    fig, ax = plt.subplots(figsize=(8, 4))
    
    # построение гистограммы для количественных признаков
    sns.histplot(data, x=column, bins=20, kde=True, hue=target, ax=ax)
    ax.set_title(f'Гистограмма для {column}', fontsize=14)
    ax.set_ylabel('Количество', fontsize=12)
    
    # окончательная настройка графика
    plt.suptitle(title)
    plt.tight_layout()
    plt.show()


# In[93]:


# посмотрим, как интенет-магазин коммуницировал с покупателями с помощью маркетинговых рассылок на протяжении последних 6 месяцев
numeric_segment(sale, 'маркет_актив_6_мес', 'сегментация_акции', 'Среднемесячное значение маркетинговых коммуникаций на одного покупателя за последние 6 мес.')


# In[94]:


# посмотрим, как интенет-магазин коммуницировал с покупателями с помощью маркетинговых рассылок в текущем месяце
numeric_segment(sale, 'маркет_актив_тек_мес', 'сегментация_акции', 'Количество маркетинговых коммуникаций в текущем мес.')


# **Примечание:** По двум построенным графикам, отображающим количество маркетинговых коммуникаций компании с покупателями на протяжении последних 6 месяцев и текущего месяца, показывают, что обычные пользователи и пользователи, отобранные в "Исследуемый сегмент" получали одинаковое количество рассылок, каких-то дополнительных про-акций для определенной категории покупателей не было.

# In[95]:


# визуализация признака 'популярная_категория'
categorical(sale, 'популярная_категория', 'Популярные категории товаров у покупателя за последние 6 мес.')


# **Примечание:** Самой популярной категорией для "Исследуемого сегмента" стала "Товыра для детей", на втором месте "Домашний текстиль", третье место "Косметика и аксесуары". Возможно данные покупки в основном совершают молодые мамы или домохозяйки, которые нуждаются в постоянных товарах для детей или для дома, но не хотят тратить на них много денег. В таком случае, закупить много товаров, еще и по скидке, хорощий вариант для такой категории пользователей.

# In[96]:


# посмотрим, сколько в среднем категорий покупатель просмотрел за визит в течение последнего месяц
numeric_segment(sale, 'средний_просмотр_категорий_за_визит', 'сегментация_акции', 'Количество категорий в среднем, которые покупатель просмотрел за визит за последний мес.')


# **Примечание:** В среднем покупатели из нашего "Исследуемого сегмента" смотрят столько же категорий за визит, что и остальные покупатели.

# In[97]:


# посмотрим общее число неоплаченных товаров в корзине за последние 3 месяца
numeric_segment(sale, 'неоплаченные_продукты_штук_квартал', 'сегментация_акции', 'Общее число неоплаченных товаров в корзине за последние 3 мес.')


# **Примечание:** В целом можно сказать, что пользователи из нашего "Исследуемого сегмента" оставляют в корзине больше неоплаченных товаров, чем покуют, как показал график.

# In[98]:


# посмотрим среднее количество страниц, которые просмотрел покупатель за один визит на сайт за последние 3 месяца
numeric_segment(sale, 'страниц_за_визит', 'сегментация_акции', 'Среднее количество страниц, которые просмотрел покупатель за один визит на сайт за последние 3 мес.')


# **Примечание:** По полученному графику можно сказать, что наши пользователи смотрят не так и много страниц за один визит, по сравнению с остальными пользователями, возможно, потому что они просматривают только страницы со скидками и акциями.

# In[99]:


# посмотрим количество минут, проведенных на сайте за предыдущий месяц
numeric_segment(sale, 'минут_предыдущий_месяц', 'сегментация_акции', 'Количество минут на сайте за предыдущий мес.')


# In[100]:


# посмотрим количество минут, проведенных на сайте за текущий месяц
numeric_segment(sale, 'минут_текущий_месяц', 'сегментация_акции', 'Количество минут на сайте за текущий мес.')


# **Примечание:** Можно сказать, что в среднем пользователи нашего "Исследуемого сегмента" проводят на сайте от 8 до 10 минут, что снова может быть связано с тем, что они просматривают категории товаров только с действующими скидками.

# **Обобщающий вывод этапа "Сегментация покупателей":**
# 
# **Исследуемый сегмент:** Группа клиентов с максимальной долей покупок по акции и высокой вероятностью снижения покупательской активности.
# 
# Для него получилось сделать следующие выводы:
# 1. Покупатели, выбранные нами в "Исследуемый сегмент" стремятся покупать товары по акции и в основном на уровне сервиса "стандарт", но, как показывает график, товары уровня сервис "премиум" иногда тоже покупаются.
# 2. По двум построенным графикам, отображающим количество маркетинговых коммуникаций компании с покупателями на протяжении последних 6 месяцев и текущего месяца, показывают, что обычные пользователи и пользователи, отобранные в "Исследуемый сегмент" получали одинаковое количество рассылок, каких-то дополнительных про-акций для определенной категории покупателей не было.
# 3. Самой популярной категорией для "Исследуемого сегмента" стала "Товыра для детей", на втором месте "Домашний текстиль", третье место "Косметика и аксесуары". Возможно данные покупки в основном совершают молодые мамы или домохозяйки, которые нуждаются в постоянных товарах для детей или для дома, но не хотят тратить на них много денег. В таком случае, закупить много товаров, еще и по скидке, хорощий вариант для такой категории пользователей.
# 4. В среднем покупатели из нашего "Исследуемого сегмента" смотрят столько же категорий за визит, что и остальные покупатели.
# 5. В целом можно сказать, что пользователи из нашего "Исследуемого сегмента" оставляют в корзине больше неоплаченных товаров, чем покуют, как показал график.
# 6. По полученному графику можно сказать, что наши пользователи смотрят не так и много страниц за один визит, по сравнению с остальными пользователями, возможно, потому что они просматривают только страницы со скидками и акциями.
# 7. Можно сказать, что в среднем пользователи нашего "Исследуемого сегмента" проводят на сайте от 8 до 10 минут, что снова может быть связано с тем, что они просматривают категории товаров только с действующими скидками.
# 
# **Таким образом,** чтобы удержать клиентов, которые часто покупают товары по акции и при этом не снизить их покупательскую активность, необходимо размещать все товары по акциям или скидкам в одном разделе, так как наши пользователи не очень охотно посещают много страниц за один визит, а тем более не тратят на это много времени. Или можно разместить часто покупаемые товары этих пользователей на главной странице интернет магазина, чтобы отображать скдки по ним.

# ## Итоговые выводы

# В ходе работы были проанализированы данные, предоставленные интернет-магазином "В олин клик", который хочет разработать решение, позволяющие персонализировать предложения постоянным клиентам, чтобы увеличить их покупательскую активность.
# 
# Было реализовано 8 этапов работы.
# **1 этап: Загрузка и изучение данных** Во время проведения этого этапа было проанализировано четыре файла с данными ('market_file', 'market_money', 'market_time', 'money'):
# 1. Данные в трех из четырех таблиц соответсвуют описанию задачи.
# 2. В данных отсутствуют пропуски.
# 3. В каждой таблице необходимо привести названия столбцов к общему стилю.
# 
# **2 этап: Предобработка данных** На этом этапе было сделано:
# 1. В таблицах названия столбцов были приведены к общему стилю.
# 2. Пропуски в данных отсутствуют.
# 3. В таблице 'market_file' было найдено 11 явных дубликатов, но пока они удалены не были. В других трех таблицах явные дубликаты отсутствуют.
# 4. В таблицах 'market_file' и 'market_time' обработаны все неявные дубликаты.
# 
# **3 этап: Исследовательский анализ данных** На этом этапе было выявлено, что:
# 1. В таблице 'marlet_file' было выявлено небольшое количество выбросов у признака "маркет_актив_6_мес", но они не были удалены, так как в значительной мере не влияют на общий ход исследования. Также было выдвинуто предположение о том, что признаки "маркет_актив_тек_мес" и "акционные_покупки" можно отнести к ряду категориальных признаков.
# 2. В таблице 'market_money' для признака "выручка" были удалены аномально большие (больше 100 000) и аномально маленькие (равные 0.00) значения вырочки, которые могли бы негативно отразиться на исследовании.
# 3. В оставших двух таблицах все впорядке, аномалии обнаружены не были.
# 4. Был проведен отбор клиентов с покупательской активностью не менее трех месяцев, после отбора в исходном датафрейме осталось 1296 строк из исходных 1300 строк для анализа.
# 
# **4 этап: Объединение таблиц** На этом этапе все три таблицы ('market_file', 'market_money', 'market_time') были успешно объединены в одну.
# 
# **5 этап: Проведение корреляционного анализа** На нем были сделаны такие выводы:
# 
# **Целевой признак:** "покупательская_активность"
# 1. Целовой признак имеет тесную корреляционную связь со следующими входными признаками:
# - "маркет_актив_6_мес";
# - "акционные_покупки";
# - "средний_просмотр_категорий_за_визит";
# - "неоплаченные_продукты_штук_квартал";
# - "страниц_за-визит";
# - "выручка_препредыдущий_месяц";
# - "минут_предыдущий_месяц";
# - "минут_текущий_месяц".
# 2. Между признаками "выручка_текущий_месяц" и "выручка_предыдущий_месяц" прослеживается высокий коэффициент корреляции, равный 0,84, данное явление похоже на мультиколинеарность, однако эти признаки пока что удалять не будем.
# 3. Между столбцом 'id' и целевым признаком "покупательская_активность" получился подозрительно очень высокий коэффициент корреляции. Такое явление является довольно странным, потому что столбец 'id' не оказывает никакого влияния на целевой признак. В дальнейше работе, чтобы устранить это явление, столбец 'id' стоит привести к столбцу с индексами.
# 
# **6 этап: Применение пайплайнов** На нем было выявлено:
# 1. Наилучшей моделью оказалась **LogisticRegression()** с параметрами: (C=3, penalty='l1', random_state=42, solver='liblinear'). Метрика лучшей модели на тренировочной выборке: 0.89.
# 2. Для оценки качества модели LogisticRegression() лучше использовать метрики **ROC-AUC** и **F1-мера**, потому что они учитывают важные аспекты классификации, которые метрика *accuracy* может упустить. Также данные метрики учитывают дисбаланс классов.
# 3. На тестовой выборке значения метрик показали: ROC-AUC: 0.91 и F1-score: 0.89. Полученные значения являются достаточно высокими, а, значит, что модель хорошо справляется с предсказаниями.
# 
# **7 этап: Анализ важности признаков** На нем были сделаны следующие выводы:
# 
# По полученным методом SHAP графикам можно сказать, что:
# 1. **Мало значимые признаки для модели**: "выручка_предыдущий_месяц", "популярная_категория" (а именно: Техника для красоты и здоровья, Товары для детей, Кухонная посуда, Косметика и аксесуары), "выручка_текущий_месяц", "ошибка_сервиса", "длительность", "разрешить_сообщать" (оба ответа: да и нет), "тип_сервиса" (оба варианта" премиум и стандарт), "маркет_актив_тек_мес".
# 2. **Признаки, сильнее всего влияющие на целевой признак *("покупательская_активность")***: "страниц_за_визит", "средний_просмотр_категорий_за_визит", "минут_предыдущий_месяц", "минут_текущий_месяц", "неоплаченные_продукты_штук_квартал".
# 3. **Напишем выводы для сильно значимых признаков по графику beeswarm**:
# - Чем больше значения признаков "страниц_за_визит", "средний_просмотр_категорий_за-визит", "минут_предыдущий_месяц", "минут_текущий_месяц", тем меньше SHAP‑значения объектов. Если у наблюдения высокое значение этих признаков, то у него высокая вероятность принадлежности к классу 0.
# - Чем больше значения признака "неоплаченные_продукты_штук_квартал", тем выше SHAP-значения. Если у наблюдения высокое значение этого признака, то у него высокая вероятность принадлежности к классу 1.
# 5. **Как можно использовать эти наблюдения при моделировании и принятии бизнес-решений?** На мой взгляд, стоит делать упор на признаки, которые сильнее всего влияют на целевой признак *(перечислены в пункте №2)*. Для удержания постоянных клиентов и поддержания их покупательской активности необходимо, чтобы они проводили больше времени на сайте и просматривали как можно больше страниц за свое посещение. Это, в том числе, позволит увеличить среднее количество просмотренных категорий и количество добавленных в корзину товаров, даже если они пока что неоплаченные. С таким уровнем вовлеченности и большим выбором у клиента будет возможность обратиться к своей предварительно собранной корзине и выбрать оттуда товары, которые по душе среди различных альтернатив, чтобы совершить итоговую покупку, и принести прибыль интернет-магазину.
# 
# **8 этап: Сегментация покупателей** На нем были получены следуюшие результаты:
# 
# **Исследуемый сегмент**: Группа клиентов с максимальной долей покупок по акции и высокой вероятностью снижения покупательской активности.
# 
# Для него получилось сделать следующие выводы:
# 1. Покупатели, выбранные нами в "Исследуемый сегмент" стремятся покупать товары по акции и в основном на уровне сервиса "стандарт", но, как показывает график, товары уровня сервис "премиум" иногда тоже покупаются.
# 2. По двум построенным графикам, отображающим количество маркетинговых коммуникаций компании с покупателями на протяжении последних 6 месяцев и текущего месяца, показывают, что обычные пользователи и пользователи, отобранные в "Исследуемый сегмент" получали одинаковое количество рассылок, каких-то дополнительных про-акций для определенной категории покупателей не было.
# 3. Самой популярной категорией для "Исследуемого сегмента" стала "Товыра для детей", на втором месте "Домашний текстиль", третье место "Косметика и аксесуары". Возможно данные покупки в основном совершают молодые мамы или домохозяйки, которые нуждаются в постоянных товарах для детей или для дома, но не хотят тратить на них много денег. В таком случае, закупить много товаров, еще и по скидке, хорощий вариант для такой категории пользователей.
# 4. В среднем покупатели из нашего "Исследуемого сегмента" смотрят столько же категорий за визит, что и остальные покупатели.
# 5. В целом можно сказать, что пользователи из нашего "Исследуемого сегмента" оставляют в корзине больше неоплаченных товаров, чем покуют, как показал график.
# 6. По полученному графику можно сказать, что наши пользователи смотрят не так и много страниц за один визит, по сравнению с остальными пользователями, возможно, потому что они просматривают только страницы со скидками и акциями.
# 7. Можно сказать, что в среднем пользователи нашего "Исследуемого сегмента" проводят на сайте от 8 до 10 минут, что снова может быть связано с тем, что они просматривают категории товаров только с действующими скидками.
# 
# **Итоговый вывод:** Таким образом, чтобы удержать клиентов, которые часто покупают товары по акции и при этом не снизить их покупательскую активность, необходимо размещать все товары по акциям или скидкам в одном разделе, так как наши пользователи не очень охотно посещают много страниц за один визит, а тем более не тратят на это много времени. Или можно разместить часто покупаемые товары этих пользователей на главной странице интернет магазина, чтобы отображать скдки по ним.
