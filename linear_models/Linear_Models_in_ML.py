#!/usr/bin/env python
# coding: utf-8

# ## Линейные модели в машинном обучении

# **Описание проекта:**
# 
# Вы работаете в IT-компании, которая выполняет на заказ проекты по машинному обучению. К вам обратился фермер, владелец молочного хозяйства «Вольный луг». Он хочет купить бурёнок, чтобы расширить поголовье стада коров. Для этого он заключил выгодный контракт с ассоциацией пастбищ «ЭкоФерма».
# 
# 
# Условия позволяют фермеру очень тщательно отобрать коров. Он определяет качество молока по строгой методике, и при этом ему нужно выполнять свой план развития молочного хозяйства. Фермер хочет, чтобы каждая бурёнка давала не менее 6000 килограммов молока в год, а её надой был вкусным — строго по его критериям, ничуть не хуже. А продавцы и технологи так и норовят приукрасить своих коровок!
# 
# 
# Поэтому он просит вас разработать модель машинного обучения, которая поможет ему управлять рисками и принимать объективное решение о покупке. «ЭкоФерма» готова предоставить подробные данные о своих коровах. Вам нужно создать две прогнозные модели для отбора бурёнок в поголовье:
# 
# 1. Первая будет прогнозировать возможный удой коровы (*целевой признак Удой*);
# 2. Вторая — рассчитывать вероятность получить вкусное молоко от коровы (*целевой признак Вкус молока*).
# 
# С помощью модели нужно отобрать коров по двум критериям:
# - средний удой за год — не менее 6000 килограммов;
# - молоко должно быть вкусным.

# **Цель проекта:** Разработать линейную модель машинного обучения, которая позволит фермеру, владельцу молочного хозяйства "Вольный луг", управлять рисками и принимать объективные решения о покупках.

# **Описание данных:**
# 
# **1.** Файл **ferma_main.csv** содержит данные о стаде фермера на текущий момент. 
# - id — уникальный идентификатор коровы.
# - Удой, кг — масса молока, которую корова даёт в год (в килограммах).
# - ЭКЕ (Энергетическая кормовая единица) — показатель питательности корма коровы.
# - Сырой протеин, г — содержание сырого протеина в корме (в граммах).
# - СПО (Сахаро-протеиновое соотношение) — отношение сахара к протеину в корме коровы.
# - Порода — порода коровы.
# - Тип пастбища — ландшафт лугов, на которых паслась корова.
# - порода папы_быка — порода папы коровы.
# - Жирность,% — содержание жиров в молоке (в процентах).
# - Белок,% — содержание белков в молоке (в процентах).
# - Вкус молока — оценка вкуса по личным критериям фермера, бинарный признак (вкусно, не вкусно).
# - Возраст — возраст коровы, бинарный признак (менее 2 лет, более 2 лет).
# 
# **2.** Файл **ferma_dad.csv** хранит имя папы каждой коровы в стаде фермера. 
# - id — уникальный идентификатор коровы.
# - Имя Папы — имя папы коровы.
# 
# **3.** Файл **cow_buy.csv** — это данные о коровах «ЭкоФермы», которых фермер хочет изучить перед покупкой. 
# - Порода — порода коровы.
# - Тип пастбища — ландшафт лугов, на которых паслась корова.
# - порода папы_быка — порода папы коровы.
# - Имя_папы — имя папы коровы.
# - Текущая_жирность,% — содержание жиров в молоке (в процентах).
# - Текущий_уровень_белок,% — содержание белков в молоке (в процентах).
# - Возраст — возраст коровы, бинарный признак (менее 2 лет, более 2 лет).

# **План работы с проектом:**
# 1. Загрузка и изучение данных;
# 2. Предобработка данных;
# 3. Исследовательский анализ данных;
# 4. Проведение корреляционного анализа признаков в датасете ferma_main.csv;
# 5. Задача регресии;
# 6. Задача классификации;
# 7. Формирование итоговых выводов.

# ## 1 шаг. Загрузка и изучение данных

# In[1]:


# загрузим библиотеки, необходимые для работы
import pandas as pd
import numpy as np
from scipy import stats

# загрузим библиотеки для визуализации данных
import matplotlib.pyplot as plt
import seaborn as sns

# загрузим модули для машинного обучения
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import OneHotEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.linear_model import LinearRegression

# загрузим модули для линейной регрессии
from sklearn.metrics import mean_squared_error
from sklearn.metrics import r2_score
from sklearn.metrics import mean_absolute_error

# загрузим модули для логистической регрессии
from sklearn.metrics import accuracy_score
from sklearn.metrics import confusion_matrix
from sklearn.metrics import recall_score
from sklearn.metrics import precision_score


# ### 1.1 Загрузка и изучение данных датафрейма 'ferma_main.csv'

# Файл **ferma_main.csv** содержит данные о стаде фермера на текущий момент. 
# 
# **Описание данных:**
# - id — уникальный идентификатор коровы.
# - Удой, кг — масса молока, которую корова даёт в год (в килограммах).
# - ЭКЕ (Энергетическая кормовая единица) — показатель питательности корма коровы.
# - Сырой протеин, г — содержание сырого протеина в корме (в граммах).
# - СПО (Сахаро-протеиновое соотношение) — отношение сахара к протеину в корме коровы.
# - Порода — порода коровы.
# - Тип пастбища — ландшафт лугов, на которых паслась корова.
# - порода папы_быка — порода папы коровы.
# - Жирность,% — содержание жиров в молоке (в процентах).
# - Белок,% — содержание белков в молоке (в процентах).
# - Вкус молока — оценка вкуса по личным критериям фермера, бинарный признак (вкусно, не вкусно).
# - Возраст — возраст коровы, бинарный признак (менее_2_лет, более_2_лет).

# Признаки в датасете **ferma_main.csv** можно разделить на группы.
# 1. Характеристики коровы: id, Порода, порода папы_быка, Возраст.
# 2. Характеристики корма: ЭКЕ (Энергетическая кормовая единица), Сырой протеин, г, СПО (Сахаро-протеиновое соотношение).
# 3. Характеристика пастбища: Тип пастбища.
# 4. Характеристики молока: Удой, кг, Жирность,%, Белок,%, Вкус молока.

# In[2]:


# загрузим данные из датафрейма 'ferma_main.csv'
ferma_main = pd.read_csv('/datasets/ferma_main.csv', sep = ';')


# In[3]:


# посмотрим первые 10 строк датафрейма
ferma_main.head(10)


# In[4]:


# посмотрим общую инфрмацию о датафрейме
ferma_main.info()


# **Примечание:** По полученным результатам видно, что для корректной работы необходимо изменить тип данных в некоторых столбцах и привести названия столбцов к общему стилю. Пропуски в данных отсутствуют. Данные соответсвуют описанию задачи.

# ### 1.2 Загрузка и изучение данных датафрейма 'ferma_dad.csv'

# Файл **ferma_dad.csv** хранит имя папы каждой коровы в стаде фермера. 
# 
# **Описание данных:**
# - id — уникальный идентификатор коровы.
# - Имя Папы — имя папы коровы.

# In[5]:


# загрузим данные из датафрейма 'ferma_dad.csv'
ferma_dad = pd.read_csv('/datasets/ferma_dad.csv', sep = ';')


# In[6]:


# посмотрим первые 10 строк датафрейма
ferma_dad.head(10)


# In[7]:


# посмотрим общую информацию о датафрейме
ferma_dad.info()


# **Примечание:** По полученным результатам видно, что названия столбцов необходимо привести к общему стилю. Тип данных для столбцов указан корректно, пропуски отсутствуют. Данные соответствуют описанию задачи.

# ### 1.3 Загрузка и изучение данных датафрейма 'cow_buy.csv'

# Файл **cow_buy.csv** — это данные о коровах «ЭкоФермы», которых фермер хочет изучить перед покупкой. 
# 
# **Описание данных:**
# - Порода — порода коровы.
# - Тип пастбища — ландшафт лугов, на которых паслась корова.
# - порода папы_быка — порода папы коровы.
# - Имя_папы — имя папы коровы.
# - Текущая_жирность,% — содержание жиров в молоке (в процентах).
# - Текущий_уровень_белок,% — содержание белков в молоке (в процентах).
# - Возраст — возраст коровы, бинарный признак (менее_2_лет, более_2_лет).

# Данные в файлах **ferma_main.csv** и **cow_buy.csv** похожи, но у датасета **cow_buy.csv** несколько особенностей.
# 
# 1. Содержание белков и жиров в молоке указано на момент продажи — когда «ЭкоФерма» давала коровам свой корм.
# 2. Параметры корма ЭКЕ (Энергетическая кормовая единица), Сырой протеин, г и СПО (Сахаро-протеиновое соотношение) отсутствуют. Технологи заказчика пересмотрели подход к кормлению: для новых коров планируется увеличить значения каждого из этих параметров на 5%.
# 3. Кроме того, отсутствуют признаки Удой, кг и Вкус молока. Это целевые признаки, их необходимо предсказать.

# In[8]:


# загрузим данные из датафрейма 'cow_buy.csv'
cow_buy = pd.read_csv('/datasets/cow_buy.csv', sep = ';')


# In[9]:


# посмотрим первые 10 строк датафрейма
cow_buy.head(10)


# In[10]:


# посмотрим общую информацию о датафрейме
cow_buy.info()


# **Примечание:** По полученным результатам видно, что для корректной работы необходимо изменить тип данных в некоторых столбцах, а также привести названия столбцов к общему стил. Пропуски в данных отсутствуют. Данные соответствуют описанию задачи.
# 

# **Обобщающий вывод этапа "Загрузка и изучение данных":** 
# 1. Данные в трех таблицах соответсвуют описани задачи.
# 2. В данных отсутствуют пропуски.
# 3. В каждой таблице необходимо привести названия столбцов к общему стилю.
# 4. В двух таблицах для корректной работы необходимо изменить тип данных.

# ## 2 шаг. Предобработка данных

# ### 2.1 Предобработка данных в таблице 'ferma_main'

# In[11]:


# по результатам загрузки данных стало видно, что в таблице 'ferma_main' названия столбцов необходимо привести к общему стилю
# выведем все названия столбцов
ferma_main.columns


# In[12]:


# переименуем столбцы к общепринятому стилю
ferma_main = ferma_main.rename(columns={
    'Удой, кг' : 'milk_yield',
    'ЭКЕ (Энергетическая кормовая единица)' : 'energy_feed_unit',
    'Сырой протеин, г' : 'crude_protein',
    'СПО (Сахаро-протеиновое соотношение)' : 'sugar_protein_ratio',
    'Порода' : 'breed',
    'Тип пастбища' : 'type_of_pasture',
    'порода папы_быка' : 'daddys_breed',
    'Жирность,%' : 'fat_content',
    'Белок,%' : 'protein',
    'Вкус молока' : 'taste_of_milk',
    'Возраст' : 'age'
})


# In[13]:


# выведем первые 5 строк таблицы с переименованными столбцами
ferma_main.head()


# In[14]:


# посмотрим количество пропусков в данных
ferma_main.isna().sum()


# **Примечание:** Пропуски в данных отсутствуют.

# In[15]:


# проверим датафрейм на наличие явных дубликатов
ferma_main.duplicated().sum()


# **Примечание:** В данных присутствует 5 явных дубликатов.

# In[16]:


# выведем таблицу с явными дубликатами
ferma_main[ferma_main.duplicated()]


# **Примечание:** В таблице правда присутствует пять полностью одинаковых строк, поэтому явные дубликаты можно удалить.

# In[17]:


# удалим явные дубликаты
ferma_main = ferma_main.drop_duplicates()

# проверим количество явных дубликатов после удаления
print('Количество явных дубликатов после удаления:', ferma_main.duplicated().sum())


# In[18]:


# проверим данные на наличие неявных дубликатов
# посмотрим значения в столбцах: 'breed', 'type_of_pasture', 'daddys_bread'
print('Уникальные значения в столбце "breed":', ferma_main['breed'].unique())
print('Уникальные значения в столбце "type_of_pasture":', ferma_main['type_of_pasture'].unique())
print('Уникальные значения в столбце "daddys_breed":', ferma_main['daddys_breed'].unique())


# In[19]:


# заменим значения, которые могли привести к появлению неявных дубликатов
ferma_main['breed'] = ferma_main['breed'].replace('РефлешнСоверинг', 'Рефлешн Соверинг')
ferma_main['type_of_pasture'] = ferma_main['type_of_pasture'].replace('Равнинные', 'Равнинное')
ferma_main['daddys_breed'] = ferma_main['daddys_breed'].replace('Айдиалл', 'Айдиал')


# In[20]:


# посмотрим уникальные значения в столбцах после замены
print('Уникальные значения в столбце "breed":', ferma_main['breed'].unique())
print('Уникальные значения в столбце "type_of_pasture":', ferma_main['type_of_pasture'].unique())
print('Уникальные значения в столбце "daddys_breed":', ferma_main['daddys_breed'].unique())


# **Примечание:** Замена проведена успешно.

# In[21]:


# поменяем типы данных в некоторых столбцах
ferma_main['energy_feed_unit'] = ferma_main['energy_feed_unit'].str.replace(',', '.').astype('float')
ferma_main['sugar_protein_ratio'] = ferma_main['sugar_protein_ratio'].str.replace(',', '.').astype('float')
ferma_main['fat_content'] = ferma_main['fat_content'].str.replace(',', '.').astype('float')
ferma_main['protein'] = ferma_main['protein'].str.replace(',', '.').astype('float')


# In[22]:


# посмотрим типы данных в таблице после изменения
ferma_main.info()


# ### 2.2 Предобработка данных в таблице 'ferma_dad'

# In[23]:


# по результатам загрузки данных стало видно, что в таблице 'ferma_dad' названия столбцов необходимо привести к общему стилю
# выведем все названия столбцов
ferma_dad.columns


# In[24]:


# переименуем столбцы к общепринятому стилю
ferma_dad = ferma_dad.rename(columns={
    'Имя Папы' : 'dads_name'
})


# In[25]:


# выведем первые 5 строк таблицы с переименованными столбцами
ferma_dad.head()


# In[26]:


# посмотрим количество пропусков в данных
ferma_dad.isna().sum()


# **Примечание:** Пропуски в данных отсутствуют.

# In[27]:


# проверим датафрейм на наличие явных дубликатов
ferma_dad.duplicated().sum()


# **Примечание:** В данных отсутствуют явные дубликаты.

# In[28]:


# проверим данные на наличие неявных дубликатов
# посмотрим значения в столбцах: 'dads_name'
print('Уникальные значения в столбце "dads_name":', ferma_dad['dads_name'].unique())


# **Примечание:** Неявные дубликаты в данных отсутствуют.

# ### 2.3 Предобработка данных в таблице 'cow_buy'

# In[29]:


# по результатам загрузки данных стало видно, что в таблице 'cow_buy' названия столбцов необходимо привести к общему стилю
# выведем все названия столбцов
cow_buy.columns


# In[30]:


# переименуем столбцы к общепринятому стилю
cow_buy = cow_buy.rename(columns={
    'Порода' : 'breed',
    'Тип пастбища' : 'type_of_pasture',
    'порода папы_быка' : 'daddys_breed',
    'Имя_папы' : 'dads_name',
    'Текущая_жирность,%' : 'current_fatness',
    'Текущий_уровень_белок,%' : 'current_protein',
    'Возраст' : 'age'
})


# In[31]:


# выведем первые 5 строк таблицы с переименованными столбцами
cow_buy.head()


# In[32]:


# посмотрим количество пропусков в данных
cow_buy.isna().sum()


# **Примечание:** Пропуски в данных отсутствуют.

# In[33]:


# проверим датафрейм на наличие явных дубликатов
cow_buy.duplicated().sum()


# **Примечание:** В данных присутствует 4 явных дубликата.

# In[34]:


# выведем таблицу с явными дубликатами
cow_buy[cow_buy.duplicated()]


# **Примечание:** На самом деле данные не являются дубликатами, поэтому строки с ними удалены не будут.

# In[35]:


# проверим данные на наличие неявных дубликатов
# посмотрим значения в столбцах: 'breed', 'type_of_pasture', 'daddys_bread', 'dads_name'
print('Уникальные значения в столбце "breed":', cow_buy['breed'].unique())
print('Уникальные значения в столбце "type_of_pasture":', cow_buy['type_of_pasture'].unique())
print('Уникальные значения в столбце "daddys_breed":', cow_buy['daddys_breed'].unique())
print('Уникальные значения в столбце "dads_name":', cow_buy['dads_name'].unique())


# In[36]:


# заменим значения, которые могли привести к появлению неявных дубликатов
cow_buy['breed'] = cow_buy['breed'].replace('РефлешнСоверинг', 'Рефлешн Соверинг')
cow_buy['type_of_pasture'] = cow_buy['type_of_pasture'].replace('холмистое', 'Холмистое')
cow_buy['type_of_pasture'] = cow_buy['type_of_pasture'].replace('равнинное', 'Равнинное')


# In[37]:


# проверим данные на наличие неявных дубликатов после изменения
print('Уникальные значения в столбце "breed":', cow_buy['breed'].unique())
print('Уникальные значения в столбце "type_of_pasture":', cow_buy['type_of_pasture'].unique())


# In[38]:


# изменим тип данных в некоторых столбцах
cow_buy['current_fatness'] = cow_buy['current_fatness'].str.replace(',', '.').astype('float')
cow_buy['current_protein'] = cow_buy['current_protein'].str.replace(',', '.').astype('float')


# In[39]:


# посмотрим типы данных в таблице после изменения
cow_buy.info()


# **Обобщающий вывод этапа "Предобработка данных":**
# 1. В таблицах названия столбцов были приведены к общему стилю.
# 2. Пропуски в данных отсутствуют.
# 3. В таблице 'ferma_main' удалены явные дубликаты.
# 4. В таблицах 'ferma_main' и 'cow_buy' обработаны все неявные дубликаты.
# 5. В таблицах 'ferma_main' и 'cow_buy' все столбцы приведены к корректному типу данных.

# ## 3 шаг. Исследовательский анализ данных

# ### 3.1 Исследовательский анализ данных таблицы 'ferma_main'

# **Будут исследованы данные о стаде фермера на текущий момент.**

# In[40]:


# проведем статистический анализ всех признаков в таблице 'ferma_main'
print('Описательная статистика для количественных признаков:')
ferma_main.describe(include=[np.number])


# In[41]:


print('Описательная статистика для категориальных признаков:')
ferma_main.describe(include=['object'])


# In[42]:


# построение графиков для разных типов признаков (количественных и категориальных)
# напишем собственную функцию для визуализации количественных признаков
def numeric(data, column, title, bins=50, figsize=(15, 10)):
    # устанавливаем параметры графика
    sns.set(style="whitegrid")
    plt.figure(figsize=figsize)
    
    # создаем подграфики (фигура с двумя графиками в одной строке)
    fig, axes = plt.subplots(1, 2)
    
    # построение гистограммы для количественных признаков
    sns.histplot(data=data, x=column, bins=bins, kde=True, ax=axes[0])
    axes[0].set(xlabel=column, ylabel='Количество коров')
    
    # построение графика "Ящик с усами"
    sns.boxplot(data=data, y=column, ax=axes[1])
    axes[1].set(ylabel=column)
    
    # окончательная настройка графика
    plt.suptitle(title)
    plt.tight_layout()
    plt.show()


# In[43]:


# визуализация признака 'milk_yield'
numeric(ferma_main, 'milk_yield', 'Удой коров')


# **Примечание:** На полученных графиках ярко прослеживается один выброс, его значение, которое можно получить из описательной статистики количественных признаков, равно 45 616. Причем по гистограмме видно, что такой объем произвело не стадо коров, а лишь одна. Такое значение можно отнести к аномалии, поэтому для качественной работы далее необходимо удалить строку с этими данными как в таблице 'ferma_main', так и в таблице 'ferma_dad', так как они связаны между собой.

# In[44]:


# посмотрим строку со значениями, где 'milk_yield' = 45 616
ferma_main[ferma_main['milk_yield'] == 45616]


# In[45]:


# ограничим значения в столбце 'milk_yield', чтобы избежать выбросов
ferma_main = ferma_main.query('milk_yield <= 7300')
ferma_dad = ferma_dad[ferma_dad['id'] != 17]


# In[46]:


# проверим количество строчек в датафреймах после удаления
print('Количество строк в таблице "ferma_main"', ferma_main.shape[0])
print('Количество строк в таблице "ferma_dad"', ferma_dad.shape[0])


# In[47]:


# снова построим визуализация количественного признака 'milk_yield'
numeric(ferma_main, 'milk_yield', 'Удой коров')


# In[48]:


# визуализация признака 'energy_feed_unit'
numeric(ferma_main, 'energy_feed_unit', 'ЭКЕ (Энергетическая кормовая единица / Питательность корма коровы)')


# In[49]:


# визуализация признака 'crude_protein'
numeric(ferma_main, 'crude_protein', 'Содержание сырого протеина в корме')


# In[50]:


# визуализация признака 'sugar_protein_ratio'
numeric(ferma_main, 'sugar_protein_ratio', 'Отношение сахара к протеину в корме')


# In[51]:


# визуализация признака 'fat_content'
numeric(ferma_main, 'fat_content', 'Содержание жиров в молоке')


# In[52]:


# визуализация признака 'protein'
numeric(ferma_main, 'protein', 'Содержание белков в молоке')


# In[53]:


# напишем собственную функцию для визулизации категориальных признаков
def categorical(data, column, title, figsize=(8, 5)):
    # устанавливаем параметры графика
    sns.set(style="whitegrid")
    plt.figure(figsize=figsize)
    
    # создаем график
    ax = sns.countplot(data = data, x=column, palette="viridis")
    
    # добавляем процентное соотношение по признакам
    total = len(data)
    for p in ax.patches:
        height = p.get_height()
        ax.text(p.get_x() + p.get_width()/2.,
                height + 0.01 * total,
                f'{height/total:.1%}',
                ha="center")

    # окончательная настройка графика
    plt.title(title)
    plt.xlabel(column)
    plt.ylabel('Количество коров')
    plt.xticks()
    plt.tight_layout()
    plt.show()


# In[54]:


# визуализация признака 'breed'
categorical(ferma_main, 'breed', 'Порода коровы')


# In[55]:


# визуализация признака 'type_of_pasture'
categorical(ferma_main, 'type_of_pasture', 'Тип пастбища')


# In[56]:


# визуализация признака 'daddys_breed'
categorical(ferma_main, 'daddys_breed', 'Порода папы коровы')


# In[57]:


# визуализация признака 'taste_of_milk'
categorical(ferma_main, 'taste_of_milk', 'Вкус молока')


# In[58]:


# визуализация признака 'age'
categorical(ferma_main, 'age', 'Возраст коровы')


# ### 3.2 Исследовательский анализ данных таблицы 'ferma_dad'

# **Таблица хранит данные об имени папы каждой коровы фермера в стаде.**

# In[59]:


# проведем статистический анализ категориальных признаков в таблице 'ferma_dad'
print('Описательная статистика для категориальных признаков:')
ferma_dad.describe(include=['object'])


# In[60]:


# визуализация признака 'dads_name'
categorical(ferma_dad, 'dads_name', 'Имя папы коровы')


# ### 3.3 Исследовательский анализ данных таблицы 'cow_buy'

# **Таблица хранит данные о коротвах "ЭкоФермы", которые фермер хочет изучить перед покупкой.**

# In[61]:


# проведем статистический анализ всех признаков в таблице 'cow_buy'
print('Описательная статистика для количественных признаков:')
cow_buy.describe(include=[np.number])


# In[62]:


print('Описательная статистика для категориальных признаков:')
cow_buy.describe(include=['object'])


# In[63]:


# визуализация признака 'breed'
categorical(cow_buy, 'breed', 'Порода коровы')


# In[64]:


# визуализация признака 'type_of_psture'
categorical(cow_buy, 'type_of_pasture', 'Тип пастбища')


# In[65]:


# визуализация признака 'daddys_breed'
categorical(cow_buy, 'daddys_breed', 'Порода папы коровы')


# In[66]:


# визуализация признака 'dads_name'
categorical(cow_buy, 'dads_name', 'Имя папы коровы')


# In[67]:


# визуализация признака 'age'
categorical(cow_buy, 'age', 'Возраст')


# In[68]:


# визуализация признака 'current_fatness'
numeric(cow_buy, 'current_fatness', 'Содержание жиров в молоке')


# In[69]:


# визуализация признака 'current_protein'
numeric(cow_buy, 'current_protein', 'Содержание белков в молоке')


# **Обобщающий вывод этапа "Исследовательский анализ данных":**
# 
# **Результаты о стаде фермера на текущий момент ('ferma_main')**:
# 1. Данные по признаку "Удой, который корова дает в год" в целом распределены нормально, для этого призако также было удалено аномальное значение. Средний удой составляет около 6 189 кг в год.
# 2. Среднее значение признака "ЭКЕ (Энергетическая кормовая единица)" составляет 14,6. График для признака немного смещен вправо.
# 3. Среднее значение признака "Содержание сырого протеина в корме" равно 1 923 грамма. График для признака смещен влевло.
# 4. Среднее значение признака "Отношение сахара к протеину в корме коровы" равно 0,91. График для признака визуально можно разделить на две половины (меньше и больше 0.90).
# 5. Среднее значение признака "Содержание жиров в молоке" равно 3,60. Наблюдаются выбросы.
# 6. Среднее значение признака "Содержание белков в молоке" равно 3,07. Данные по признаку распределены нормально.
# 7. В стаде преобладают коровы породы "Вис Бик Айдиал", которые пасуться на холмистом пастбище.
# 8. Возраст более 80% коров более двух лет.
# 9. В больше, чем 50% случаев коровы дают вкусное молоко.
# **Данные о коровах для покупки ('cow_buy') в целом схожи с данными о коровах на текущий момент.**

# ## 4 шаг. Проведение корреляционного анализа признаков в датасете ferma_main.csv

# ### 4.1 Изучение взаимосвязи между признаками, рассчет коэффициентов корреляции

# In[70]:


# отделим количественные признаки в наборе данных 'ferma_main' в отдельную переменную
numeric_col = ['milk_yield', 'energy_feed_unit', 'crude_protein', 'sugar_protein_ratio', 'fat_content', 'protein']

# рассчитаем коэффиценты корреляции для количественных признаков
ferma_main[numeric_col].corr()


# In[71]:


# нарисуем тепловую карту для визуализации результатов полученных коэффициентов корреляции
plt.figure(figsize=(8,4))
sns.heatmap(
    ferma_main[numeric_col].corr(),        
    cmap='RdBu_r',
    annot=True, 
    vmin=-1, vmax=1)


# ### 4.2 Построение диаграмм рессеяния

# In[72]:


# напишем собственную функцию для построения диаграммы рассеивания
def scatterplot(data, categorical_col, target_col='milk_yield', cols_to_drop=['id']):

    # выбираем только количественные признаки
    numeric_cols = data.select_dtypes(include=['number']).columns
    numeric_cols = numeric_cols.drop([target_col] + cols_to_drop)
    
    # устанавливаем параметры графика
    sns.set(style="whitegrid")
    plt.figure(figsize=(15, 10)) 
    
    # посчитаем количество строк для сетки графика
    rows = (len(numeric_cols) + 1) // 2  
    fig, axes = plt.subplots(rows, 2, figsize=(12, rows*4))
    
    # убираем лишнее пустое поле, т.к. количественных признаков всего 5, а сетка строится 3х2 (визуальное оформление)
    for ax in axes.flat[len(numeric_cols):]:
        ax.set_visible(False)

    # напишем цикл для построения графиков в сетке
    for ax, feature in zip(axes.flat, numeric_cols):
        sns.scatterplot(data=data, x=feature, y=target_col, hue=categorical_col,
                   palette='viridis', alpha=0.5, ax=ax)
        ax.set_title(f'"Удой коров" и признак {feature} по {categorical_col}')
        ax.set_xlabel(feature)
        ax.set_ylabel(target_col)
        ax.legend(loc='upper left')
    # окончательная настройка графика
    plt.tight_layout()
    plt.show()  


# In[73]:


scatterplot(ferma_main, categorical_col='breed')


# In[74]:


scatterplot(ferma_main, categorical_col='type_of_pasture')


# In[75]:


scatterplot(ferma_main, categorical_col='daddys_breed')


# In[76]:


scatterplot(ferma_main, categorical_col='taste_of_milk')


# In[77]:


scatterplot(ferma_main, categorical_col='age')


# **Обобщающий вывод этапа "Проведение корреляционного анализа признаков в датасете ferma_main.csv":**
# 
# **Типы взаимосвязи между целевым и входными признаками:**
# 1. Связь между признаками "Удой коровы" и "ЭКЕ (Энергетическая кормовая единица)" линейная и сильная, это подтвержает полученные коэффициент корреляции равный 0,77.
# 2. Связь между признаками "Удой коровы" и "Сырой протеин" линейная, но умеренная, так как коэффициент корреляции равен 0,45.
# 3. Признаки "Удой коровы" и "СПО (Сахаро-протеиновое соотношение)" не имеют линейной связи, признак СПО более похож на категориальный, так как данные распределены по определенным значениям.
# 4. Коэффициент корреляции между признаками "Удой коров" и "Содержание жиров в молоке" достаточно высокий (0,6), также стоит отметить, что коровы дают в основном молоко с высоким процентом жирности.
# 5. Между признаками "Удой коров" и "Содержание белков в молоке" связь отсутствует.
# 
# **Между целевым признаком и некоторыми входными признаки присутствует нельнейная связь**, а именно:
# 
# **Целевой признак:** "Удой коровы"
# 
# **Входные признаки:** "СПО (Сахаро-протеиновое соотношение)", "Содержание жиров в молоке" и "Содержание белков в молоке".
# 
# **Мультиколлинеарность между входными признаками не наблюдается.**

# ## 5 шаг. Обучение модели линейной регрессии (Задача регрессии)

# ### 5.1 Первая модель линейной регрессии

# **Целевой признак:** - 'milk_yield' (Удой коров, кг).
# 
# **Признаки, которые будут взяты для модели линейной регрессии:**
# 
# **Количественные признаки:**
# 1. 'energy_feed_unit': ЭКЕ (энергетическая кормовая единица) - показатель питательности корма коровы, от нее напрямую зависит насыщаемость коровы, что приводит к получению определенного количества молока.
# 2. 'crude_protein': Сырой протеин - содержание сырого протеина в корме влиет на его питательность для коровы, поэтому можно взять этот признак для построение модели.
# 3. 'sugar_protein_ratio': СПО (Сахаро-протеиновое отношение) - отношение сахара к протеину в корме коровы. Данный признак не имеет линейной связи с признаком "Удой коровы, кг", но может влиять на показатель питательности корма, поэтому будет взят в модель.
# 
# **Категориальные признаки:**
# 1. 'breed': От породы коровы может зависить, какой объем молока она дает.
# 2. 'type_of_pasture': От типа пастбища, на котором паслась корова, также может зависить состояние самой коровы, которые влияет на количество получаемого молока.
# 3. 'daddys_breed': От породы папы коровы может зависить состояние самой коровы, какие у нее особенности и способности, что также влияет на производительность самой коровы.
# 4. 'age': От возраста коровы зависит ее состояние производить определенный объем молока.

# In[78]:


# напишем собственную функцию для обучения модели линейной регрессии
def model_lr(data, cat_col_names, num_col_names):
    # копируем датасет в новую переменную, чтобы при работе не изменить исходные данные
    df = data.copy()
    
    RANDOM_STATE = 42

    X = df.drop('milk_yield', axis=1)
    y = df['milk_yield']
    
    # разбиваем данные на тренировочную и тестовую выборки
    X_train, X_test, y_train, y_test = train_test_split(
        X, 
        y, 
        random_state=RANDOM_STATE)

    # проводим кодирование категориальных признаков
    encoder = OneHotEncoder(drop='first', sparse=False)
    X_train_ohe = encoder.fit_transform(X_train[cat_col_names])
    X_test_ohe = encoder.transform(X_test[cat_col_names])

    encoder_col_names = encoder.get_feature_names()
    
    # проводим масштабирование количественных признаков
    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train[num_col_names])
    X_test_scaled = scaler.transform(X_test[num_col_names])

    # перепишем данные в переменные с закодированными и мащтабированными признаками
    X_train_ohe = pd.DataFrame(X_train_ohe, columns=encoder_col_names)
    X_test_ohe = pd.DataFrame(X_test_ohe, columns=encoder_col_names)

    X_train_scaled = pd.DataFrame(X_train_scaled, columns=num_col_names)
    X_test_scaled = pd.DataFrame(X_test_scaled, columns=num_col_names)

    # соединеяем обработанные данные в единые тренировочные и тестовые выборки
    X_train = pd.concat([X_train_ohe, X_train_scaled], axis=1)
    X_test = pd.concat([X_test_ohe, X_test_scaled], axis=1)

    # проводим обучение модели и получение предсказаний на тестовых данных
    model_lr = LinearRegression()
    model_lr.fit(X_train, y_train)
    predictions = model_lr.predict(X_test)

    # оценим качество моделей с помощью метрик
    metrics = {
    'R2': r2_score(y_test, predictions),
    'MAE': mean_absolute_error(y_test, predictions),
    'MSE': mean_squared_error(y_test, predictions),
    'RMSE': mean_squared_error(y_test, predictions, squared=False) 
    }
    
    # проведем анализ остатков
    # рассчитаем остатки
    residuals = y_test - predictions

    # построим графики по количественным признакам — гистограмму частотности распределения и диаграмму рассеяния
    fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(10,5))
    axes[0].hist(residuals, bins=50)
    axes[0].set_title('Гистограмма распределения остатков')
    axes[0].set_xlabel('Остатки')

    axes[1].scatter(predictions, residuals)
    axes[1].set_xlabel('Предсказания модели')
    axes[1].set_ylabel('Остатки')
    axes[1].set_title('Анализ дисперсии')
    plt.show()
    
    return {
        'Модель': model_lr,
        'Рассчитанные для модели метрики': metrics,
    }


# In[79]:


cat_col_names_1 = ['breed', 'type_of_pasture', 'daddys_breed', 'age']
num_col_names_1 = ['energy_feed_unit', 'crude_protein', 'sugar_protein_ratio']
model_lr(ferma_main, cat_col_names_1, num_col_names_1)


# **Выводы по первой модели:**
# 1. R2 (коэффициент детерминации) = 0,78, показывает, что модель линейной регрессии хорошо предсказывает данные в 78%.
# 2. Гистограма распределения остатков показывает нормальное распределение, однако, график имеет небольшое смещение влево, что говорит о том, что модель часто дает слишком большие предсказания, ее прогнозы выше истинных значений.
# 3. Также видно, что разница между минимумом и максимумом остатков при различных прогнозных значениях модели меняется. Дисперсия между значениями на оси Y непостоянна на протяжении всей оси X. Это говорит о том, что модель ошибается, и, скорее всего переоценивает или недооценивает предсказания значений целевого признака.

# ### 5.2 Вторая модель линейной регрессии

# **На 4 шаге проекта** были построены диаграммы рассеивания, по которым стало видно, что **СПО (сахаро-протеиновое отношение)** не имеет линейной связи с целевым признаком и больше похож на категориальный признак, так как его значения делятся на две категории по левую и правую сторону от значения 0,91.
# 
# Поэтому для **устранения нелинейности** необходимо преобразовать "СПО" в бинарный категориальный признак, используя границу 0,91.

# In[80]:


# преобразуем признак СПО в бинарный категориальный признак
ferma_main['spr'] = ferma_main['sugar_protein_ratio'].apply(lambda x: 'более_0.91' if x > 0.91 else 'менее_0.91')


# **На 4 шаге проекта** по диаграмме рассеивания также видно, что признак **ЭКЕ (энергетическая кормовая единица)** также нелинейно связана с целевым признаком "Удой коров, кг". Чтобы устранить нелинейность, можно возвести признак ЭКЕ в квадрат.

# In[81]:


# возведем значения признакак ЭКЕ в квадрат
ferma_main['square_energy_feed_unit'] = ferma_main['energy_feed_unit'] ** 2


# In[82]:


cat_col_names_2 = ['breed', 'type_of_pasture', 'daddys_breed', 'age', 'spr']
num_col_names_2 = ['square_energy_feed_unit', 'crude_protein']
model_lr(ferma_main, cat_col_names_2, num_col_names_2)


# **Выводы по второй модели:**
# 1. R2 (коэффициент детерминации) = 0,81, показывает, что модель линейной регрессии хорошо предсказывает данные в 81%, а значит, ошибается только в 19% случаев.
# 2. Гистограма распределения остатков показывает нормальное распределение, однако, график имеет небольшое смещение вправо, это значит, что прогнозы модели меньше фактических значений целевого признака.
# 3. Также видно, что разница между минимумом и максимумом остатков при различных прогнозных значениях модели меняется. Дисперсия между значениями на оси Y непостоянна на протяжении всей оси X. Это говорит о том, что модель ошибается, и, скорее всего переоценивает или недооценивает предсказания значений целевого признака. Дисперсия остатков увеличивается на больших значениях.

# ### 5.3 Третья модель линейной регрессии

# In[83]:


# добавим признак 'dads_name' к изучаемому датафрему
ferma_main = ferma_main.merge(ferma_dad, on='id')


# In[84]:


cat_col_names_3 = ['breed', 'type_of_pasture', 'daddys_breed', 'age', 'spr', 'dads_name']
num_col_names_3 = ['square_energy_feed_unit', 'crude_protein']
model_lr(ferma_main, cat_col_names_3, num_col_names_3)


# **Выводы по третьей модели:**
# 1. R2 (коэффициент детерминации) = 0,82, показывает, что модель линейной регрессии хорошо предсказывает данные в 82%, а значит, ошибается только в 18% случаев. Коэффициент детерминации у третье модели выше двух предыдущих моделей.
# 2. Гистограма распределения остатков показывает нормальное распределение, однако, график все равно имеет небольшое смещение влево.
# 3. Также видно, что разница между минимумом и максимумом остатков при различных прогнозных значениях модели меняется. Дисперсия между значениями на оси Y непостоянна на протяжении всей оси X. Это говорит о том, что модель ошибается, и, скорее всего переоценивает или недооценивает предсказания значений целевого признака. Дисперсия остатков увеличивается на больших значениях.
# 4. Анализ метрик MAE, MSE, RMSE показывают минимальные значения для третьей модели.
# 
# **Все данные выводы позволяют сказать, что третья модель является наиболее точной для предсказаний.**

# In[95]:


# напишем собственную функцию для возвращения необходимых показателей для третьей модели
def model_lr_3(data, cat_col_names, num_col_names):
    # копируем датасет в новую переменную, чтобы при работе не изменить исходные данные
    df = data.copy()
    
    RANDOM_STATE = 42

    X = df.drop('milk_yield', axis=1)
    y = df['milk_yield']
    
    # разбиваем данные на тренировочную и тестовую выборки
    X_train, X_test, y_train, y_test = train_test_split(
        X, 
        y, 
        random_state=RANDOM_STATE)

    # проводим кодирование категориальных признаков
    encoder = OneHotEncoder(drop='first', sparse=False)
    X_train_ohe = encoder.fit_transform(X_train[cat_col_names])
    X_test_ohe = encoder.transform(X_test[cat_col_names])

    encoder_col_names = encoder.get_feature_names()
    
    # проводим масштабирование количественных признаков
    scaler = StandardScaler()
    X_train_scaled = scaler.fit_transform(X_train[num_col_names])
    X_test_scaled = scaler.transform(X_test[num_col_names])

    # перепишем данные в переменные с закодированными и мащтабированными признаками
    X_train_ohe = pd.DataFrame(X_train_ohe, columns=encoder_col_names)
    X_test_ohe = pd.DataFrame(X_test_ohe, columns=encoder_col_names)

    X_train_scaled = pd.DataFrame(X_train_scaled, columns=num_col_names)
    X_test_scaled = pd.DataFrame(X_test_scaled, columns=num_col_names)

    # соединеяем обработанные данные в единые тренировочные и тестовые выборки
    X_train = pd.concat([X_train_ohe, X_train_scaled], axis=1)
    X_test = pd.concat([X_test_ohe, X_test_scaled], axis=1)

    # проводим обучение модели и получение предсказаний на тестовых данных
    model_lr = LinearRegression()
    model_lr.fit(X_train, y_train)
    predictions = model_lr.predict(X_test)
    
    return model_lr, predictions, y_test, encoder, scaler


# In[96]:


# вытащим предсказания для третьей (лучшей) модели
model_lr_3, predictions_3, y_test_3, encoder_3, scaler_3 = model_lr_3(ferma_main, cat_col_names_3, num_col_names_3)

# рассчитаем доверительный интервал прогноза для лучшей модели
interval = stats.norm.interval(confidence= 0.95 , loc=np.mean(predictions_3), scale=stats.sem(predictions_3))
print(f'Доверительный интервал модели: {interval[0].round(2)} - {interval[1].round(2)}')


# ### 5.4 Прогноз удоя коров на основе лучшей модели ('cow_buy')

# In[87]:


# добавление ЭКЕ (Энергетической кормовой единицы), увеличенной на 5%
cow_buy['square_energy_feed_unit'] = (((ferma_main['energy_feed_unit'].mean() * 1.05))**2).round(2)

# добавление Сырого протеина, увеличенного на 5%
cow_buy['crude_protein'] = (ferma_main['crude_protein'].mean() * 1.05).round(2)

# добавление СПО (сахаро-протеиновое отношение), увеличенного на 5%
cow_buy['sugar_protein_ratio'] = ferma_main['sugar_protein_ratio'].mean() * 1.05

# приведение признака СПО к категориальному виду
cow_buy['spr'] = cow_buy['sugar_protein_ratio'].apply(lambda x: 'более_0.91' if x > 0.91 else 'менее_0.91')


# In[97]:


# спрогнозируем удой коров, которых хочет купить фермер

# выполним подготовку данных, аналогичную той, что делали выше, но на основе лучшей модели
# кодируем категориальные признаки с помощью 'encoder_3' третьей (лучшей) модели
cow_buy_ohe = encoder_3.transform(cow_buy[cat_col_names_3])
encoder_col_names = encoder_3.get_feature_names()
# перепишем данные с закодированными признаками в переменную
cow_buy_ohe = pd.DataFrame(cow_buy_ohe, columns=encoder_col_names)

# масштабируем количественные признаки с помощью 'scaler_3' третье (лучшей) модели
cow_buy_scaled = scaler_3.transform(cow_buy[num_col_names_3])
# перепишем данные с масштабированными признаками в переменную
cow_buy_scaled = pd.DataFrame(cow_buy_scaled, columns=num_col_names_3)

# соединяем обработанные данные в единую переменную
cow_buy_final = pd.concat([cow_buy_ohe, cow_buy_scaled], axis=1)

# получаем предсказания с помощью третьей (лучшей) модели
cow_buy_predictions = model_lr_3.predict(cow_buy_final).round(4) # ставим округления для вывода предсказаний без появления ошибок


# In[98]:


# запишем предсказания в исходный датафрейм 'cow_buy'
cow_buy['milk_yield'] = final_predictions 


# In[99]:


# отберем данные по тем коровам, чей удой (кг) в год соответствует диапазону найденного доверительного интервала
cow_buy[cow_buy['milk_yield'] > 6000]


# **Обощающий вывод этапа "Обучение модели линейной регрессии (Задача регрессии)":**
# 1. Для датафрейма 'ferma_main' (целевой признак: 'milk_yield') было построено три модели линейной регрессии.
# - Для построения модели линейной регрессии категориальные признаки кодировались;
# - Для построения модели линейной регрессии количественные признаки масштабировались;
# - Для улучшения качества модели признак "СПО" был привед к бинарному-категориальному, а значения признака "ЭКЕ" были возведены в квадрат.
# - Для каждой из трех моделей были рассчитаны метрики качествва, а также проведены анализы остатков.
# 2. Лучшей моделью по всем проанализированным показателям оказалась модель №3, ее R2 = 0,82. Он показывает, что модель линейной регрессии хорошо предсказывает данные в 82%, а значит, ошибается только в 18% случаев.
# 3. С помощью третьей модели были спрогнозированы значения удоя коров, которых фермер хочет купить (датафрейм 'cow_buy').

# ## 6 шаг. Обучение модели логистической регрессии (Задача классификации)

# ### 6.1 Построение модели логистической регрессии

# В качестве целевого признака будет использоваться **"Вкус молока" ('taste_of_milk')**, поэтому его необходимо привести к количественному типу признака.
# 
# **Характеристика признака:** 1 - вкусно, 0 - невкусно.

# In[101]:


# преобразование признака "Вкус молока" к количественному типу признака
ferma_main['taste_of_milk'] = ferma_main['taste_of_milk'].apply(lambda x: 1 if x == 'вкусно' else 0)

# посмотрим признак "Вкус молока" после преобразования
ferma_main.head(10)


# **Признаки, которые будут взяты для модели логистической регрессии:**
# 
# **Количественные признаки:**
# 1. 'square_energy_feed_unit': ЭКЕ (энергетическая кормовая единица) - показатель питательности корма коровы, от нее напрямую зависит насыщаемость коровы, что приводит к получению определенного количества молока, а также его вкуса.
# 2. 'crude_protein': Сырой протеин - содержание сырого протеина в корме влиет на его питательность для коровы, от чего зависит вкус молока, которое она дает.
# 3. 'fat_content': Жирность, % - содержание жиров в молоке, которые сильно могут влиять на вкус молока.
# 4. 'protein': Белок, % - содержание белков в молоке, которые сильно могут влиять на вкус молока.
# 5. 'milk_yield': Удой, кг - масса молока, которое корова дает в год, этот признак может влияет на способность короыв производить молоко определенного вкуса и в целом.
# 
# **Категориальные признаки:**
# 1. 'breed': От породы коровы может зависить вкус молока, которое она дает.
# 2. 'type_of_pasture': От типа пастбища, на котором паслась корова, также может зависить состояние самой коровы, которые влияет на вкус молока, которое она дает.
# 3. 'daddys_breed': От породы папы коровы может зависить состояние самой коровы, какие у нее особенности и способности, какое молоко по вкусу она дает.
# 4. 'age': От возраста коровы зависит ее состояние производить определенный объем молока, а также вкус самого молока.
# 5. 'spr': СПО (Сахаро-протеиновое отношение) - отношение сахара к протеину в корме коровы. Данный признак не имеет линейной связи с признаком "Удой коровы, кг", но может влиять на показатель питательности корма, поэтому будет взят в модель.

# In[112]:


# копируем датасет в новую переменную, чтобы при работе не изменить исходные данные
ferma_main = ferma_main.copy()
    
RANDOM_STATE = 42

X = ferma_main.drop('taste_of_milk', axis=1)
y = ferma_main['taste_of_milk']
    
# разбиваем данные на тренировочную и тестовую выборки
X_train, X_test, y_train, y_test = train_test_split(
    X, 
    y, 
    random_state=RANDOM_STATE)

cat_col_names = ['breed', 'type_of_pasture', 'daddys_breed', 'age', 'spr']
num_col_names = ['square_energy_feed_unit', 'crude_protein', 'fat_content', 'protein', 'milk_yield']

# проводим кодирование категориальных признаков
encoder = OneHotEncoder(drop='first', sparse=False)
X_train_ohe = encoder.fit_transform(X_train[cat_col_names])
X_test_ohe = encoder.transform(X_test[cat_col_names])

encoder_col_names = encoder.get_feature_names()
    
# проводим масштабирование количественных признаков
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train[num_col_names])
X_test_scaled = scaler.transform(X_test[num_col_names])

# перепишем данные в переменные с закодированными и мащтабированными признаками
X_train_ohe = pd.DataFrame(X_train_ohe, columns=encoder_col_names)
X_test_ohe = pd.DataFrame(X_test_ohe, columns=encoder_col_names)

X_train_scaled = pd.DataFrame(X_train_scaled, columns=num_col_names)
X_test_scaled = pd.DataFrame(X_test_scaled, columns=num_col_names)

# соединеяем обработанные данные в единые тренировочные и тестовые выборки
X_train = pd.concat([X_train_ohe, X_train_scaled], axis=1)
X_test = pd.concat([X_test_ohe, X_test_scaled], axis=1)

# проводим обучение модели и получение предсказаний на тестовых данных
clf = LogisticRegression()

clf = clf.fit(X_train, y_train)
y_pred = clf.predict(X_test)

# оценим качество моделей с помощью метрик
metrics = {
    'Accuracy': accuracy_score(y_test, y_pred),
    'Recall': recall_score(y_test, y_pred),
    'Precision': precision_score(y_test, y_pred),
    }
print(metrics)

# построим матрицу ошибок
cm = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues_r')
plt.ylabel('True label')
plt.xlabel('Predicted')


# **Анализ полученной логистической регрессии:**
# 
# **Главное для закзчика - вкусное молоко.**
# 1. Модель в 46 случаях показывает "Ошибку 1-го рода", это значит, что ошибочно предсказывает факт того, что молоко вкусное.
# 2. Модель в 12 случаях показывает "Ошибку 2-го рода", это значит, что ошибочно предсказывает факт того, что молоко невкусное.
# 
# Так как для заказчика в первую очередь важен **вкус молока**, то необходимо минимизировать "Ошибку 1-го рода", чтобы не получилось ситуации, что молоко было предсказано вкусным, а по факту оказалось невкусным и разочаровало фермера или покупателя молока.
# 
# 3. Метрика "Recall" (полнота), показывает, смогла ли модель классификации присвоить класс 1 всем объектам этого класса. Она показывает ошибки 2-го рода, но чем выше метрика, тем больше правильных прогнозов ('Positive') смогла сделать модель. По нашим результатам "Recall" = 0,86.
# 4. Метрика "Precision" (точность) показывает точность, с которой модель присваивает объектам класс 1, то есть получает результат типа Positive. Иными словами, precision определяет, не слишком ли часто модель выставляет класс 1 объектам класса 0. Чем выше эта метрика, тем меньше таких случаев, а у по результатам "Precision" = 0,62.
# 
# **Необходимо минимизировать "Ошибку 1-го рода".**

# ### 6.2 Снижение критической ошибки

# In[113]:


# выведем объекты по убыванию вероятности их принадлежности к классу 
y_proba = clf.predict_proba(X_test)[:,1]

data = pd.DataFrame(zip(y_test, y_proba),
             columns = ['y_valid', 'y_proba']).sort_values(by='y_proba',ascending=False)

print(data.head()) 


# In[123]:


# разобьем промежуток на 1000 мелких для подбора подходящего порога принадлежности к классам
thresholds = [round(i,2) for i in np.linspace(0.1,1,num = 100,endpoint=False)]
print(thresholds) 


# In[124]:


# посмотрим результаты работы модели при разных пороговых значения
columns = []

# добавим столбцы с новыми предсказаниями в таблицу
for i in thresholds:
    columns.append('y_pred_'+str(i))
    data['y_pred_'+str(i)] = data['y_proba'].apply(lambda x: 1 if x>=i else 0)

data.sample(5)


# In[131]:


# рассчитаем оптимальный порог
for i in thresholds:
    y_pred = data[f'y_pred_{threshold}']
    precision = round(precision_score(y_test, y_pred), 2)
    tn, fp, fn, tp = confusion_matrix(y_test, y_pred).ravel()
    
    if fp == 0:
        print(f'Порог = {threshold}')
        porog = threshold
        break


# In[132]:


# заново рассчитаем метрики качества модели для найденного порога
metrics = {
    'Accuracy': accuracy_score(y_test, data['y_pred_'+str(porog)]).round(2),
    'Recall': recall_score(y_test, data['y_pred_'+str(porog)]).round(2),
    'Precision': precision_score(y_test, data['y_pred_'+str(porog)]).round(2),
    }
print(metrics)


# In[135]:


# заново построим матрицу ошибок для найденного порога
cm = confusion_matrix(y_test, data['y_pred_'+str(porog)])
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues_r')
plt.ylabel('True label')
plt.xlabel('Predicted')


# **Вывод по минимизации "Ошибки 1-го рода":** При пороге = 0,84 модель логистической регрессии полностью исключает появление "Ошибки 1-го рода".

# ### 6.3 Прогноз вкуса молока коров, которых хочет купить фермер ('cow_buy')

# In[146]:


# создадим столбец с признаком 'taste_of_milk'
cow_buy['taste_of_milk'] = cow_buy.get('taste_of_milk', 0)


# In[147]:


# напишем признаки для датафрейма 'cow_buy', т.к. "Жирность, %" и "Белок, %" называются иначе
cat_col_names_4 = ['breed', 'type_of_pasture', 'daddys_breed', 'age', 'spr']
num_col_names_4 = ['square_energy_feed_unit', 'crude_protein', 'current_fatness', 'current_protein', 'milk_yield']

# спрогнозируем вкус молока коров, которых хочет купить фермер

# выполним подготовку данных, налогисную той, что делали выше
# кодируем категориальные признаки
cow_buy_ohe_milk = encoder.transform(cow_buy[cat_col_names_4])
encoder_col_names_milk = encoder.get_feature_names()
# переписываем данные с закодированными признаками в переменную
cow_buy_ohe_milk = pd.DataFrame(cow_buy_ohe_milk, columns=encoder_col_names_milk)

# масштабируем количественные признаки
cow_buy_scaled_milk = scaler.transform(cow_buy[num_col_names_4])
# переписываем данные с масштабированными признаками в переменную
cow_buy_scaled_milk = pd.DataFrame(cow_buy_scaled_milk, columns=num_col_names_4)

# соединяем обработанные данные в единую переменную
cow_buy_milk_final = pd.concat([cow_buy_ohe_milk, cow_buy_scaled_milk], axis=1)

# получаем предсказания с помощью модели логистической регрессии
cow_buy_milk_predictions = clf.predict_proba(cow_buy_milk_final)[:,1]


# In[148]:


# отберем данные по "вкусу молока", которые соответствуют классификации по полученному пороговому значения (0,84)
cow_buy['taste_of_milk'] = (cow_buy_milk_predictions >= 0.84).astype(int)

# выведем полученный прогноз
cow_buy


# **Обощающий вывод этапа "Обучение модели логистической регрессии (Задача классификации)":**
# 1. На основе датафрейма 'ferma_main' была обучена модель логистической регрессии.
# 2. Был получен порог классификации = 0,84, при котором модель вовсе не будет допускать "Ошибку 1-го рода".
# 3. По полученному прогнозу получилось, что коровы, которых хочет купить фермер ('cow_buy') всегда дают невкусное молоко.

# ## Итоговые выводы

# В ходе работы были проанализированы данные, предоставленные фермером, владельцем молочного хозяйства "Вольный луг", который хочет купить буренок пастбищ "ЭкоФерма", чтобы расширить поголовье стада коров.
# 
# Было реализовано 6 этапов работы.
# 
# **1 этап: Загрузка и изучение данных.** Во время проведения этого этапа было пронализирована три файла с данными ('ferma_main', 'ferma_dad', 'cow_buy'):
# 1. Все файлы с данными соответствуют описанию задачи.
# 2. В файлах отсутствуют пропущенные значения.
# 3. Некоторые названия столбцов имеют неприемлемый стиль.
# 4. В некоторых столбцах указан некоректный тип данных.
# 
# **2 этап: Предобработка данных.** На этом этапе было сделано:
# 1. В таблицах названия столбцов были приведены к общему стилю.
# 2. В таблице 'ferma_main' удалены явные дубликаты.
# 3. В таблицах 'ferma_main' и 'cow_buy' обработаны все неявные дубликаты.
# 4. В таблицах 'ferma_main' и 'cow_buy' все столбцы приведены к корректному типу данных.
# 
# **3 этап: Исследовательский анализ данных.** На этом этапе было выявлено, что:
# 
# **Результаты о стаде фермера на текущий момент ('ferma_main')**:
# 1. Данные по признаку "Удой, который корова дает в год" в целом распределены нормально, для этого призако также было удалено аномальное значение. Средний удой составляет около 6 189 кг в год.
# 2. Среднее значение признака "ЭКЕ (Энергетическая кормовая единица)" составляет 14,6. График для признака немного смещен вправо.
# 3. Среднее значение признака "Содержание сырого протеина в корме" равно 1 923 грамма. График для признака смещен влевло.
# 4. Среднее значение признака "Отношение сахара к протеину в корме коровы" равно 0,91. График для признака визуально можно разделить на две половины (меньше и больше 0.90).
# 5. Среднее значение признака "Содержание жиров в молоке" равно 3,60. Наблюдаются выбросы.
# 6. Среднее значение признака "Содержание белков в молоке" равно 3,07. Данные по признаку распределены нормально.
# 7. В стаде преобладают коровы породы "Вис Бик Айдиал", которые пасуться на холмистом пастбище.
# 8. Возраст более 80% коров более двух лет.
# 9. В больше, чем 50% случаев коровы дают вкусное молоко.
# **Данные о коровах для покупки ('cow_buy') в целом схожи с данными о коровах на текущий момент.**
# 
# **4 этап: Проведение корреляционного анализа признаков в датасете ferma_main.csv.** На нем были сделаны такие выводы:
# 
# **Типы взаимосвязи между целевым и входными признаками:**
# 1. Связь между признаками "Удой коровы" и "ЭКЕ (Энергетическая кормовая единица)" линейная и сильная, это подтвержает полученные коэффициент корреляции равный 0,77.
# 2. Связь между признаками "Удой коровы" и "Сырой протеин" линейная, но умеренная, так как коэффициент корреляции равен 0,45.
# 3. Признаки "Удой коровы" и "СПО (Сахаро-протеиновое соотношение)" не имеют линейной связи, признак СПО более похож на категориальный, так как данные распределены по определенным значениям.
# 4. Коэффициент корреляции между признаками "Удой коров" и "Содержание жиров в молоке" достаточно высокий (0,6), также стоит отметить, что коровы дают в основном молоко с высоким процентом жирности.
# 5. Между признаками "Удой коров" и "Содержание белков в молоке" связь отсутствует.
# 
# **Между целевым признаком и некоторыми входными признаки присутствует нельнейная связь**, а именно:
# 
# **Целевой признак:** "Удой коровы"
# 
# **Входные признаки:** "СПО (Сахаро-протеиновое соотношение)", "Содержание жиров в молоке" и "Содержание белков в молоке".
# **Мультиколлинеарность между входными признаками не наблюдается.**
# 
# **5 этап: Обучение модели линейной регрессии (Задача регрессии).** После проведения обучения модели линейной регрессии, результаты были таковы:
# 1. Для датафрейма 'ferma_main' (целевой признак: 'milk_yield') было построено три модели линейной регрессии.
# - Для построения модели линейной регрессии категориальные признаки кодировались;
# - Для построения модели линейной регрессии количественные признаки масштабировались;
# - Для улучшения качества модели признак "СПО" был привед к бинарному-категориальному, а значения признака "ЭКЕ" были возведены в квадрат.
# - Для каждой из трех моделей были рассчитаны метрики качествва, а также проведены анализы остатков.
# 2. Лучшей моделью по всем проанализированным показателям оказалась модель №3, ее R2 = 0,82. Он показывает, что модель линейной регрессии хорошо предсказывает данные в 82%, а значит, ошибается только в 18% случаев.
# 3. С помощью третьей модели были спрогнозированы значения удоя коров, которых фермер хочет купить (датафрейм 'cow_buy').
# 
# **6 этап: Обучение модели логистической регрессии (Задача классификации).** После проведения обучения модели логистической регрессии, результаты были таковы:
# 1. На основе датафрейма 'ferma_main' была обучена модель логистической регрессии.
# 2. Был получен порог классификации = 0,84, при котором модель вовсе не будет допускать "Ошибку 1-го рода".
# 3. По полученному прогнозу получилось, что коровы, которых хочет купить фермер ('cow_buy') всегда дают невкусное молоко.
# 
# **Итоговый вывод:** По полученным прогнозам, стало видно, что буренки, которых фермер хочет купить, приносят в год около 6 000 кг молока, но в основном все молоко невкусное, что не удовлятворяет потребностей фермера и покупателя в будущем. Поэтому не сстоит покупать коров у ассоциации пастбищ "ЭкоФерма".
# 
